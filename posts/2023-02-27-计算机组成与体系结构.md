---
title: "计算机组成与体系结构"
date: "2023-02-27 22:28:25"
slug: "Computer-Composition-And-Architecture"
tags: "计算机基础"
categories:
  - "计算机基础"
---

# 计算机组成与体系结构前言

- 数据的表示
- 计算机结构
- Flynn分类法
- CISC与RISC
- 流水线技术
- 存储系统
- 总线系统
- 可靠性
- 校验码

## 数据的表示

### 进制

#### R进制转换十进制

按权展开法，具体为：将R进制数的每一位数值用R<sup>k</sup>形式表示，即幂的底数是R,指数为k,k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间的数码的个数加1。

例子：

二进制：10100.01 = 1x2<sup>4</sup>+1x2<sup>2</sup>+1x2<sup>-2</sup>

七进制：604.01 = 6x7<sup>2</sup>+4x7<sup>0</sup>+1x7<sup>-2</sup>

#### 十进制转换R进制

短除法。

例如：94转为二进制数

```shell
2 | 94 余 0
2 | 47    1
2 | 23    1
2 | 11    1
2 | 5     1
2 | 2     0
  1       1

==> 1011110
```

#### 二进制转八进制转十六进制

```javascript
8E(16)
// 分区
[8][E] -> 10001110(2)

10 001 110(2)
// 分区
[010][001][110] -> 2 1 6(8)

```

### 编码

#### 机器数

一个数在计算中的表示形式就是二进制，这个数其实就叫机器数。机器数是带有符号，计算机用最高位存放符号，这个bit一般叫做符号位。正数的符号位为0，负数的符号位为1。

一个byte有8bit,最大值是 0111 1111(+127),最小值是 1111 1111(-127)，在计算机中之所以使用二进制来表示原码是因为逻辑简单，对于电路来说就只有开跟关两种状态，用二进制是最方便的。

#### 原码

十进制的二进制表示形式就是原码，原码的最左边的一个数字就是符号位，0为正，1为负。

##### 正数计算

使用原码对正数计算不会有任何问题，运算完结果转换为十进制与答案相符

例如：5+2

```shell
0 0 0 0 0 1 0 1
+       0 0 1 0
----------------
0 0 0 0 0 1 1 1 
1x2^0+1x2^1+1x2^2 = 7
```

##### 负数计算

如果是负数计算，结果就会大相径庭

例如：-56 - 1

```shell
1 0 1 1 1 0 0 0 
-             1
---------------
1 0 1 1 0 1 1 1
2^0+2^1+2^2+2^4+2^5 = -(1+2+4+16+32) = -55
```

十进制的计算结果应该是 -57，转换为原码计算后结果变成了 -55

为了解决原码不能计算负数的问题，发码作为负数计算的救星出现了，计算规则是正数的反码不变和原码一致，负数的反码会在原码的基础上，高位的符号位不变，其他位取反。

#### 反码

正数的反码是其本身，负数的反码是符号位保持不变，其他位取反，反码的存在是为了计算负数，因为原码不能计算负数

| 十进制数字 | 原码      | 反码      |
| ---------- | --------- | --------- |
| +0         | 0000 0000 | 0000 0000 |
| -0         | 1000 0000 | 1000 0000 |
| -1         | 1000 0001 | 1111 1110 |
| -2         | 1000 0010 | 1111 1101 |
| -3         | 1000 0011 | 1111 1100 |
| -4         | 1000 0100 | 1111 1011 |
| -5         | 1000 0101 | 1111 1010 |
| -6         | 1000 0110 | 1111 1001 |
| -7         | 1000 0111 | 1111 1000 |

例如：负数计算，还是 -56 - 1,-56的原码为 1011 1000,它的反码为 1100 0111

```shell
1 1 0 0 0 1 1 1
-             1
-----------------
1 1 0 0 0 1 1 0
// ->反码
1 0 1 1 1 0 0 1
1+2^3+2^4+2^5=-(1+8+16+32)=-57
```

##### 跨零计算

反码也有它的软肋，如果是负数跨零计算，计算得出的结果也不对

例如：-3+5

-3的原码是 1000 0011，反码是 1111 1100

```shell
1 1 1 1 1 1 0 0
+       0 1 0 1
----------------
0 0 0 0 0 0 0 1
// ->反码
1 1 1 1 1 1 1 0 
-126
```

上述的结果显然是不对的，这时候作为反码的补充编码，补码就出现了

#### 补码

正数的补码是它本身，负数的补码是其反码 +1，因为反码不能解决负数跨零计算的问题，所以补码出现了

| 十进制数字 | 原码      | 反码      | 补码      |
| ---------- | --------- | --------- | --------- |
| +0         | 0000 0000 | 0000 0000 | 0000 0000 |
| -0         | 1000 0000 | 1111 1111 | 0000 0000 |
| -1         | 1000 0001 | 1111 1110 | 1111 1111 |
| -2         | 1000 0010 | 1111 1101 | 1111 1110 |
| -3         | 1000 0011 | 1111 1100 | 1111 1101 |
| -4         | 1000 0100 | 1111 1011 | 1111 1100 |
| -5         | 1000 0101 | 1111 1010 | 1111 1011 |
| -6         | 1000 0110 | 1111 1001 | 1111 1010 |
| -7         | 1000 0111 | 1111 1000 | 1111 1001 |
| ...        | ...       | ...       | ...       |
| -127       | 1111 1111 | 1000 0000 | 1000 0001 |
| -128       | 无        | 无        | 1000 0000 |

##### 跨零计算

例如 -3 + 5

-3的源码是 1000 0011，反码是1111 1100，补码是 1111 1101，

```shell
1 1 1 1 1 1 0 1
+       0 1 0 1
----------------
0 0 0 0 0 0 1 0
2
```

这个数转为十进制就刚好等2，结果正确了。

在计算机当中都是使用补码来进行计算和存储的，补码很好地解决了反码负数不能跨零计算的弊端，并且补码还可以记录一个特殊的值 -128，这个数据在1个字节下是没有原码和反码的。

#### 移码

移码用来表示浮点数的阶码，它只能表示整数。

| 十进制数字 | 原码      | 反码      | 补码      | 移码      |
| ---------- | --------- | --------- | --------- | --------- |
| 1          | 0000 0001 | 0000 0001 | 0000 0001 | 1000 0001 |
| +0         | 0000 0000 | 0000 0000 | 0000 0000 | 1000 0000 |
| -0         | 1000 0000 | 1111 1111 | 0000 0000 | 0000 0000 |
| -1         | 1000 0001 | 1111 1110 | 1111 1111 | 0111 1111 |

移码就是在真值x上加上一个常数偏置值，通常这个常数取2<sup>n</sup>,相当于在x轴上向正方向偏移了若干单位

十进制整数21，移码字长为8位，则偏置值为2<sup>7</sup>

| 真值x  | 移码机器数[x]移                       |
| ------ | ------------------------------------- |
| +10101 | 1001 0101【1000 0000 + 0001 0101】    |
| -10101 | 0001 0101【1000 0000 + (-0001 0101)】 |

1. 移码中零的表示唯一。[+0]<sub>移</sub>=2<sup>n</sup>+0=[-0]<sub>移</sub>=2<sup>n</sup>-0 = 100
2. 一个真值的移码和补码仅仅差了一个符号位，[x]<sub>补</sub>的符号位取反即得[x]<sub>移</sub>，反之亦然
3. 移码全0时，对应的真值的最小值-2<sup>n</sup>，移码全1时，对应的真值的最大值2<sup>n</sup>-1
4. 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

补码、移码比较

| 真值   | 补码      | 移码      |
| ------ | --------- | --------- |
| -128   | 1000 0000 | 0000 0000 |
| -127   | 1000 0001 | 0000 0001 |
| -126   | 1000 0010 | 0000 0010 |
| ...... | ......    | ......    |
| -3     | 1111 1101 | 0111 1101 |
| -2     | 1111 1110 | 0111 1110 |
| -1     | 1111 1111 | 0111 1111 |
| 0      | 0000 0000 | 1000 0000 |
| 1      | 0000 0001 | 1000 0001 |
| 2      | 0000 0010 | 1000 0010 |
| 3      | 0000 0011 | 1000 0011 |
| ...... | ......    | ......    |
| 125    | 0111 1101 | 1111 1101 |
| 126    | 0111 1110 | 1111 1110 |
| 127    | 0111 1111 | 1111 1111 |

若把移码看作无符号，则会发现真值是正常递增的数，所以移码表示的整数很方便比较大小

#### 取值范围

| 码制 | 整数                                      |
| ---- | ----------------------------------------- |
| 原码 | -(2<sup>n-1</sup>-1)~+(2<sup>n-1</sup>-1) |
| 反码 | -(2<sup>n-1</sup>-1)~+(2<sup>n-1</sup>-1) |
| 补码 | -2<sup>n-1</sup>~+(2<sup>n-1</sup>-1)     |
| 移码 | -2<sup>n-1</sup>~+(2<sup>n-1</sup>-1)     |