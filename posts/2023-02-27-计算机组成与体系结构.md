---
title: "计算机组成与体系结构"
date: "2023-02-27 22:28:25"
slug: "Computer-Composition-And-Architecture"
tags: "计算机基础"
categories:
  - "计算机基础"
---

# 计算机组成与体系结构前言

- 数据的表示
- 计算机结构
- Flynn分类法
- CISC与RISC
- 流水线技术
- 存储系统
- 总线系统
- 可靠性
- 校验码

## 数据的表示

### 进制

#### R进制转换十进制

按权展开法，具体为：将R进制数的每一位数值用R<sup>k</sup>形式表示，即幂的底数是R,指数为k,k与该位和小数点之间的距离有关。当该位位于小数点左边，k值是该位和小数点之间数码的个数，而当该位位于小数点右边，k值是负值，其绝对值是该位和小数点之间的数码的个数加1。

例子：

二进制：10100.01 = 1x2<sup>4</sup>+1x2<sup>2</sup>+1x2<sup>-2</sup>

七进制：604.01 = 6x7<sup>2</sup>+4x7<sup>0</sup>+1x7<sup>-2</sup>

#### 十进制转换R进制

短除法。

例如：94转为二进制数

```shell
2 | 94 余 0
2 | 47    1
2 | 23    1
2 | 11    1
2 | 5     1
2 | 2     0
  1       1

==> 1011110
```

#### 二进制转八进制转十六进制

```javascript
8E(16)
// 分区
[8][E] -> 10001110(2)

10 001 110(2)
// 分区
[010][001][110] -> 2 1 6(8)

```

### 编码

#### 机器数

一个数在计算中的表示形式就是二进制，这个数其实就叫机器数。机器数是带有符号，计算机用最高位存放符号，这个bit一般叫做符号位。正数的符号位为0，负数的符号位为1。

一个byte有8bit,最大值是 0111 1111(+127),最小值是 1111 1111(-127)，在计算机中之所以使用二进制来表示原码是因为逻辑简单，对于电路来说就只有开跟关两种状态，用二进制是最方便的。

#### 原码

十进制的二进制表示形式就是原码，原码的最左边的一个数字就是符号位，0为正，1为负。

##### 正数计算

使用原码对正数计算不会有任何问题，运算完结果转换为十进制与答案相符

例如：5+2

```shell
0 0 0 0 0 1 0 1
+       0 0 1 0
----------------
0 0 0 0 0 1 1 1 
1x2^0+1x2^1+1x2^2 = 7
```

##### 负数计算

如果是负数计算，结果就会大相径庭

例如：-56 - 1

```shell
1 0 1 1 1 0 0 0 
-             1
---------------
1 0 1 1 0 1 1 1
2^0+2^1+2^2+2^4+2^5 = -(1+2+4+16+32) = -55
```

十进制的计算结果应该是 -57，转换为原码计算后结果变成了 -55

为了解决原码不能计算负数的问题，发码作为负数计算的救星出现了，计算规则是正数的反码不变和原码一致，负数的反码会在原码的基础上，高位的符号位不变，其他位取反。

#### 反码

正数的反码是其本身，负数的反码是符号位保持不变，其他位取反，反码的存在是为了计算负数，因为原码不能计算负数

| 十进制数字 | 原码      | 反码      |
| ---------- | --------- | --------- |
| +0         | 0000 0000 | 0000 0000 |
| -0         | 1000 0000 | 1000 0000 |
| -1         | 1000 0001 | 1111 1110 |
| -2         | 1000 0010 | 1111 1101 |
| -3         | 1000 0011 | 1111 1100 |
| -4         | 1000 0100 | 1111 1011 |
| -5         | 1000 0101 | 1111 1010 |
| -6         | 1000 0110 | 1111 1001 |
| -7         | 1000 0111 | 1111 1000 |

例如：负数计算，还是 -56 - 1,-56的原码为 1011 1000,它的反码为 1100 0111

```shell
1 1 0 0 0 1 1 1
-             1
-----------------
1 1 0 0 0 1 1 0
// ->反码
1 0 1 1 1 0 0 1
1+2^3+2^4+2^5=-(1+8+16+32)=-57
```

##### 跨零计算

反码也有它的软肋，如果是负数跨零计算，计算得出的结果也不对

例如：-3+5

-3的原码是 1000 0011，反码是 1111 1100

```shell
1 1 1 1 1 1 0 0
+       0 1 0 1
----------------
0 0 0 0 0 0 0 1
// ->反码
1 1 1 1 1 1 1 0 
-126
```

上述的结果显然是不对的，这时候作为反码的补充编码，补码就出现了

#### 补码

正数的补码是它本身，负数的补码是其反码 +1，因为反码不能解决负数跨零计算的问题，所以补码出现了

| 十进制数字 | 原码      | 反码      | 补码      |
| ---------- | --------- | --------- | --------- |
| +0         | 0000 0000 | 0000 0000 | 0000 0000 |
| -0         | 1000 0000 | 1111 1111 | 0000 0000 |
| -1         | 1000 0001 | 1111 1110 | 1111 1111 |
| -2         | 1000 0010 | 1111 1101 | 1111 1110 |
| -3         | 1000 0011 | 1111 1100 | 1111 1101 |
| -4         | 1000 0100 | 1111 1011 | 1111 1100 |
| -5         | 1000 0101 | 1111 1010 | 1111 1011 |
| -6         | 1000 0110 | 1111 1001 | 1111 1010 |
| -7         | 1000 0111 | 1111 1000 | 1111 1001 |
| ...        | ...       | ...       | ...       |
| -127       | 1111 1111 | 1000 0000 | 1000 0001 |
| -128       | 无        | 无        | 1000 0000 |

##### 跨零计算

例如 -3 + 5

-3的源码是 1000 0011，反码是1111 1100，补码是 1111 1101，

```shell
1 1 1 1 1 1 0 1
+       0 1 0 1
----------------
0 0 0 0 0 0 1 0
2
```

这个数转为十进制就刚好等2，结果正确了。

在计算机当中都是使用补码来进行计算和存储的，补码很好地解决了反码负数不能跨零计算的弊端，并且补码还可以记录一个特殊的值 -128，这个数据在1个字节下是没有原码和反码的。

#### 移码

移码用来表示浮点数的阶码，它只能表示整数。

| 十进制数字 | 原码      | 反码      | 补码      | 移码      |
| ---------- | --------- | --------- | --------- | --------- |
| 1          | 0000 0001 | 0000 0001 | 0000 0001 | 1000 0001 |
| +0         | 0000 0000 | 0000 0000 | 0000 0000 | 1000 0000 |
| -0         | 1000 0000 | 1111 1111 | 0000 0000 | 0000 0000 |
| -1         | 1000 0001 | 1111 1110 | 1111 1111 | 0111 1111 |

移码就是在真值x上加上一个常数偏置值，通常这个常数取2<sup>n</sup>,相当于在x轴上向正方向偏移了若干单位

十进制整数21，移码字长为8位，则偏置值为2<sup>7</sup>

| 真值x  | 移码机器数[x]移                       |
| ------ | ------------------------------------- |
| +10101 | 1001 0101【1000 0000 + 0001 0101】    |
| -10101 | 0001 0101【1000 0000 + (-0001 0101)】 |

1. 移码中零的表示唯一。[+0]<sub>移</sub>=2<sup>n</sup>+0=[-0]<sub>移</sub>=2<sup>n</sup>-0 = 100
2. 一个真值的移码和补码仅仅差了一个符号位，[x]<sub>补</sub>的符号位取反即得[x]<sub>移</sub>，反之亦然
3. 移码全0时，对应的真值的最小值-2<sup>n</sup>，移码全1时，对应的真值的最大值2<sup>n</sup>-1
4. 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

补码、移码比较

| 真值   | 补码      | 移码      |
| ------ | --------- | --------- |
| -128   | 1000 0000 | 0000 0000 |
| -127   | 1000 0001 | 0000 0001 |
| -126   | 1000 0010 | 0000 0010 |
| ...... | ......    | ......    |
| -3     | 1111 1101 | 0111 1101 |
| -2     | 1111 1110 | 0111 1110 |
| -1     | 1111 1111 | 0111 1111 |
| 0      | 0000 0000 | 1000 0000 |
| 1      | 0000 0001 | 1000 0001 |
| 2      | 0000 0010 | 1000 0010 |
| 3      | 0000 0011 | 1000 0011 |
| ...... | ......    | ......    |
| 125    | 0111 1101 | 1111 1101 |
| 126    | 0111 1110 | 1111 1110 |
| 127    | 0111 1111 | 1111 1111 |

若把移码看作无符号，则会发现真值是正常递增的数，所以移码表示的整数很方便比较大小

#### 取值范围

| 码制 | 整数                                      |
| ---- | ----------------------------------------- |
| 原码 | -(2<sup>n-1</sup>-1)~+(2<sup>n-1</sup>-1) |
| 反码 | -(2<sup>n-1</sup>-1)~+(2<sup>n-1</sup>-1) |
| 补码 | -2<sup>n-1</sup>~+(2<sup>n-1</sup>-1)     |
| 移码 | -2<sup>n-1</sup>~+(2<sup>n-1</sup>-1)     |

#### 浮点数运算

表示：N = M * R<sup>e</sup>,M为尾数，e是指数，R为基数

对阶 => 尾数计算 => 结果格式化

## 计算机结构

计算机结构(主机)：

1. 主存储器 
2. CPU
   1. 运算器
      1. 算术逻辑单元ALU
      2. 累加寄存器AC
      3. 数据缓冲寄存器DR
      4. 状态条件寄存器PSW
   2. 控制器
      1. 程序计数器PC
      2. 指令寄存器IR
      3. 指令译码器
      4. 时序部件

## Flynn分类法

| 体系结构类型          | 结构                                               | 关键特性                               | 代表                                   |
| --------------------- | -------------------------------------------------- | -------------------------------------- | -------------------------------------- |
| 单指令流单数据流-SISD | 控制部分：一个<br/>处理器：一个<br/>主存模块：一个 |                                        | 单处理器系统                           |
| 单指令流多数据流-SIMD | 控制部分：一个<br/>处理器：多个<br/>主存模块：多个 | 各处理器以异步的形式执行同一条指令     | 并行处理机、阵列处理机、超级向量处理机 |
| 多指令流单数据流-MISD | 控制部分：多个<br/>处理器：一个<br/>主存模块：多个 | 被证明是不可能，至少是不实际的         | 目前没有，有文献称流水线计算机为此类   |
| 多指令流多数据流-MIMD | 控制部分：多个<br/>处理器：多个<br/>主存模块：多个 | 能够实现作业、任务、指令等各级全面并行 | 多处理系统多计算                       |

## CISC与RISC

| 指令系统类型 | 指令                                                         | 寻址方式   | 实现方式                                             | 其他                       |
| ------------ | ------------------------------------------------------------ | ---------- | ---------------------------------------------------- | -------------------------- |
| CISC（复杂） | 数量多，使用频率差别大                                       | 支持多种   | 微程序控制技术（微码）                               | 研制周期长                 |
| RISC（精简） | 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式少 | 增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线 | 优化编译，有效支持高级语言 |

## 流水线技术

### 概念

流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度

=> 取指 => 分析 => 执行 =>

### 计算

#### 执行时间

流水线周期为执行时间最长的一段，流水线计算公式为：

1条指令执行时间 +（指令条件 - 1）* 流水线周期,k为一周期的段数

1. 理论公式：(t1,t2+...+tk) + (n-1) * △t
2. 实际公式：(k + n - 1) * △t

例：若指令流水线把一条分为取值、分析、执行三部分，且三部分的时间分别是2ns、2ns、1ns，那么流水线周期是多少？100条指令全部执行完毕需要的时间是多少？

```shell
1.理论公式：
(2+2+1) + (100 - 1) * 2 = 203ns
2.实际公式：
(3 + 100 - 1) * 2 = 204ns
```

#### 吞吐率

Though Put rate,TP 是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算流水线吞吐率的基本公式是：

```shell
	    指令条数
TP = --------------
	  流水线执行时间
```

流水线最大吞吐率

```shell
			      n		    1
TPmax = Lim ------------ = ----
        n->∞  (k+n-1)△t    △t
```

上述例子：

```shell
	    100
TP = ---------- 
	    203
	    
			      n		    1		1
TPmax = Lim ------------ = ---- = ------
        n->∞  (k+n-1)△t    △t	 2+2+1
```

#### 加速比

完成同样一批任务，不使用流水线所用时间与使用流水线所用时间纸币称为流水线的加速比。计算流水线加速比的基本公式如下：

```shell
	    不使用流水线执行时间
S = ---------------------
	     使用流水线执行时间
```

上述例子：

```shell
	    (2+2+1)x100      500
S = ----------------- = ------
	     203             203
```

#### 效率

指流水线的设备利用率。在时空图上，流水线的效率定义为n个人物占用的时空区与k个流水段总的时空区之比

入=>S1(△t)=>S2(△t)=>S3(△t)=>S4(3△t)=>出

计算流水线效率的公式为：

```shell
	    n个任务占用的时空区	    T0
E = --------------------- = -----
	  k个流水段的总的时空区      KTK
```



## 存储系统

### 层次化存储结构

```shell
快          CPU=>寄存器
		    ||
           Cache=>按内容存取
速           ||
度        内存(主存)
             ||
慢        外存(辅存)=>硬盘、光盘、U盘等

```

#### Cache

功能：提高CPU数据输入输出的速率，突破冯诺莫瓶颈，即CPU与存储系统间数据传送带宽限制。

在计算机的存储系统体系红，Cache是访问速度最快的层次，使用Cache改善系统性能的依据是程序的局部性原理

如果以h代表对Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用Cache+主存储器的系统的平均周期为t3，则

t3 = h x t1 + (1 - h) x t2

其中,(1 - h)又称之为失效率（未命中率）

### 时间局部性与空间局部性

时间局部性

空间局部性

工作集理论：工作集是进程运行时被频繁访问的页面集合

```java
int i,s = 0;
for(i=1;i<1000;i++)
    for(j=1;j<1000;j++)
        s+=j;
printf("结果为:%d",s)
```

### 随机存储器与只读存储器

随机存取存储器

- DRAM(Dynamic RAM 动态RAM)-SDRAM
- SRAM(Static RAM,静态)

只读存储器

- MROM(Mask ROM,掩模式ROM)
- PROM(Programmable ROM,一次可编程ROM)
- EPROM(Erasable PROM,可擦除的PROM)
- 闪速存储器(flash memory,闪存)

### 磁盘工作原理

存取时间 = 寻道时间 + 等待时间(平均定位时间+转动延迟)

寻道时间是指磁头移动到磁道所需的时间：等待时间为等待读写的扇区转到磁头下方所用的时间

## 总线系统

根据总线所处位置不同，分为

- 内部总线
- 系统总线
  - 数据总线
  - 地址总线
  - 控制总线
- 外部总线

## 可靠性

### 串联系统与并联系统可靠度计算

R：可靠度,λ：失效率

串联：R = R1xR2x...xRn，λ=λ1+λ2+...+λn

并联：R =1-(1-R1)x(1-R2)x...x(1-Rn)，λ=1 - R

#### 模冗余系统与混合系统

```shell
    R1
输入 R2 表决器=> 输出
    Rm
```

```shell
   --R--  -R-
--R--R--
   --R--  -R-
整体串联，部分并联   
Rx(1-(1-R)^3)x(1-(1-R)^2)
```



## 校验码

### 差错控制，什么是检错和纠错？什么是码距？

一个编码系统的码距是整个编码系统中任意所有两个码字的最小距离

例：

若用1位长度的二进制编码。若A=1，B=0。这样A,B之间的最小码距为1。

若用2位长度的二进制编码。若A=11，B=00。这样A,B之间的最小码距为2。

若用3位长度的二进制编码。若A=111，B=000。这样A,B之间的最小码距为3。

码距与检错、纠错的关系：

1. 在一个码组内为了检测e个误码，要求最小码距d应该满足：d>=e+1
2. 在一个码组内为了检测t个误码，要求最小码距d应该满足：d>=2t+1



### 海明校验码

