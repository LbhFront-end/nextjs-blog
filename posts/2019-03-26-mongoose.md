---
title: "Mongoose"
date: "2019-03-26 16:30:00"
slug: "Database-Mongoose"
tags: "数据库相关"
categories:
  - "数据库相关"
---

MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。

Mongoose是在node.js环境下对mongodb进行便捷操作的对象模型工具

[学习链接](https://cn.mongoosedoc.top/docs/guide.html)

## 快速上手

_请先安装 MongoDB 和 Node.js。_

下一步， `npm` 安装Mongoose:

```shell
npm i mongoose
```

连接数据库test

```javascript
const mongoose = require("mongoose");
mongoose.connect("mongodb://localhost/test");
```

`connect()` 返回一个状态待定（pending）的连接，接着我们加上成功和失败的提醒：

```javascript
const db = mongoose.connection;
db.on("error", console.error.bind(console, "connection error:"));
db.once("open", function () {
  // ..
});
```

连接成功的时候，回调函数会被调用，假设下面所有函数都在这个回调函数里面。

Mongoose 里面一切始于 Schema。看一个简单的例子：

```javascript
const KittySchema = mongoose.Schema({
  name: String,
});
```

我们得到了一个带有 `String` 类型的 `name` 属性的 schema, 接着把这个 schema 编译成一个 Model:

```javascript
const Kitten = mongoose.model("Kitten", kittySchema);
```

model 是我们创造的 document 的 Class。在例子中，每个 document 都是一个实例，它的属性和行为都会被声明在 schema 。

```javascript
const felyne = new Kitten({ name: "Felyne" });
felyne.name; // 'Felyne';

// 给 document 加一个 speak 方法
KittySchema.methods.speak = function () {
  const greeting = this.name
    ? "Meow name is " + this.name
    : "I don't have a name";
  console.log(greeting);
};
const Kitten = mongoose.model("Kitten", kittySchema);
```

加在 schema 的 `methods` 属性的函数会编译到 `Model` 的prototype, 也会暴露搭配每个 document 实例：

```javascript
const a = new Kitten({
  name: "A",
});
a.speak(); // Meow name is A
```

每个 document 会在调用它的 save 方法后保存到数据库中，注意回调函数的第一个参数永远是 error

```javascript
A.save(function (err, A) {
  if (err) return console.error(err);
  A.speak();
});
```

如果有很多个实例，可以用下面的方法来获取 model 里面的所有数据

```javascript
Kitten.find(function (err, kittens) {
  if (err) return console.error(err);
  console.log(kittens);
});
```

## 模式（Schemas）

#### 定义一个schema

Mongoose 的一切始于 Schema, 每个 schama 都会映射到一个 MongoDB collection，并定义这个 collection 里面的文档的构成。

```javascript
const mongoose = require("mongoose");
const Schema = mongoose.Schema;
const blog = new Schema({
  title: String,
  author: String,
  body: String,
  comments: [
    {
      body: String,
      date: Date,
    },
  ],
  date: {
    type: Date,
    defalut: Date.now,
  },
  hidden: Boolean,
  meta: {
    votes: Number,
    favs: Number,
  },
});
```

document 里面的每个属性都会被转换成在 blogSchema 里面对应的 SchemaType。例如 `title` 属性会被转换成为 SchemaType String, 而 `date` 属性会被转换成为 SchemaType Date。还可以像 `meta` 属性一样，更加详细地指定嵌套在里面的属性类型。

运行使用的 SchemaTypes 有：

- 'String'
- 'Number'
- 'Boolean'
- 'Date'
- 'Buffer'
- 'Mixed'
- 'ObjectId'
- 'Array'

Schema 的功能不只是定义文档结构和属性类型，还可以定义

- 'document 的 instance methods'
- 'model 的 static Model methods'
- '复合索引'
- '文档的生命周期钩子，也称为中间件'

#### 创建一个 model

`mongoose.model(modelName,schema)` 函数把 schema 转换为一个 Model:

```javascript
const Blog = mongoose.model("Blob", blogSchema);
```

#### 实例方法（method）

document 是 Models 的实例。Document 有很多自带的实例方法，当然也可以自定义我们自己的方法

```javascript
// 定义一个 schema
const animalSchema = new Schema({
  name: String,
  type: String,
});

animalSchema.methods.findSimilarTypes = function (cb) {
  return this.model("Animal").find(
    {
      type: this.type,
    },
    cb,
  );
};
```

现在所有的 `animal` 实例都有 `findSimilarTypes` 方法：

```javascript
const Animal = mongoose.model('Animal', animalSchema);
const dog = new Animal({
    type： 'dog'
});

dog.findSimilarTypes(function(err, dogs) {
    console.log(dogs); // woof
});
```

- '重写 mongoose 的默认方法会造成无法预料的结果'
- '不要在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误'

#### 静态方法（static）

添加 `Model` 的静态方法也十分简单，继续使用 `animalSchema` 举例：

```javascript
animalSchema.statics.findByName = function (name, cb) {
  return this.find(
    {
      name: new RegExp(name, "i"),
    },
    cb,
  );
};
const Animal = mongoose.model("Animal", animalSchema);
Animal.findByName("fido", function (err, animals) {
  console.log(animals);
});
```

同样注意的是不要在静态方法中使用 ES6 的箭头函数

#### 查询助手（query helper）

查询助手作用于 query 实例，方便自定义扩展链式查询

```javascript
animalSchema.query.byName = function (name) {
  return this.find({
    name: new RegExp(name, "i"),
  });
};
const Animal = mongoose.model("Animal", animalSchema);
Animal.find()
  .byName("fido")
  .exec(function (err, animal) {
    console.log(animals);
  });
```

#### 索引（index）

MongoDB 支持 secondary indexes。在 mongoose 中，我们在 Schema 定义索引。索引分字段级别和 schema 级别，复合索引需要在 schema 级别定义。

```javascript
const animalSchema = new Schema({
  name: String,
  type: String,
  tags: {
    type: [String],
    index: true,
  },
});

animalSchema.index({
  name: 1,
  type: -1,
});
```

应用启动的时候，Mongoose 会自动调用 `createIndex` 初始化定义的索引。Mongoose 顺序处理每一个 createIndex，然后在 model 触发 'index' 事件。在生产中建议禁止这种行为，因为创建索引会对性能造成重大影响。

```javascript
mongoose.connect('mongodb://user:pass@localhost:port/database', {
    autoIndex: false
});
// 或者
mongoose.createConnection('mongodb://user:pass@localhost:port/database', {
    autoIndex: false
});
// 或者
new Schema({
    ..
}, {
    autoIndex: false
});
```

索引创建完成或者失败，Mongoose 会触发 index 事件

```javascript
// Will cause an error because mongodb has an _id index by default that is not sparse
animalSchema.index(
  {
    _id: 1,
  },
  {
    sparse: true,
  },
);
const Animal = mongoose.model("Animal", animalSchema);
Animal.on("index", function (err) {
  // _id index cannot be sparse
  console.log(err);
});
```

#### 虚拟值（Virtual）

Virtual 是 document 的属性，但是不会被保存到 MongoDB.getter 可以用于格式化和组合字段数据，setter 可以很方便地分解一个值到多个字段。

```javascript
const personSchema = new Schema({
  name: {
    first: String,
    last: String,
  },
});

const Person = mongoose.model("Person", personSchema);

const axl = new Person({
  name: {
    first: "Axl",
    last: "Rose",
  },
});
console.log(axl.name.first + " " + axl.name.last); //Axl Rose
```

但是每次都要这样拼接就太麻烦了，使用 virtual property getter 这个方法允许定义一个 fullName 属性，但不必保存到数据库。

```javascript
personSchema.virtual("fullName").get(function () {
  return this.name.first + " " + this.name.last;
});
console.log(axl.fullName); // Axl Rose
```

如果对 document 使用 `toJSON（）` 或 `toObject()` 默认不包括虚拟值，需要额外向 toObject 或者 toJSON 传入参数 `{virtuals:true}`

也可以设定虚拟值的 setter，下面的例子中，当赋值到虚拟值的时候，会自动拆分到其他属性

```javascript
personSchema
  .virtual("fullName")
  .get(function () {
    return this.name.first + " " + this.name.last;
  })
  .set(function (v) {
    this.name.first = v.substr(0, v.indexOf(" "));
    this.name.last = v.substr(v.indexOf(" ") + 1);
  });
axl.fullName = "William Rose"; // Now `axl.name.first` is "William"
```

需要注意的是，虚拟值不能用于查询和字段选择，因为虚拟值不存储在 MongoDB

#### 别名（Alias）

Aliase 是一种特殊的虚拟值，它的getter 和 setter 会无缝链接到另一个值，这是一个节省带宽的做法，可以存储一个更短的属性名到数据库，同时在调用的时候保持可读性。

```javascript
const personSchema = new Schema({
  n: {
    type: String,
    alias: "name",
  },
});

const person = new Person({
  name: "Val",
});
person; //{n:'Val'}
person.toObject({
  virtuals: true,
}); //{n:'Val',name:'Val'}
person.name; // Val
person.name = "Not Val";
person; // {n:'Not Val'}
```

#### 选项

Schema 有很多可配置选项，可以在构造时传入或者直接 set

```javascript
new Schema({
    ...
}, options);
const schema = new Schema({
    ...
});

schema.set(option, value);
```

有效的选项：

- 'autoIndex'
- 'bufferCommands'
- 'capped'
- 'collection'
- 'id'
- '\_id'
- 'minimize'
- 'read'
- 'shardKey'
- 'strict'
- 'strictQuery'
- 'toJSON'
- 'toObject'
- 'typekey'
- 'validateBeforeSave'
- 'versionKey'
- 'skipVersioning'
- 'timestamps'
- 'useNestedStrict'

**option：autoIndex**

应用启动的时候，Mongoose 自动发送 `createIndex` 指令，schema 里面的每个 index 都会被创建，如果需要关闭自动创建功能或者需要在创建后进行一系列操作，可以把 `autoIndex` 设为 `false` ，然后对 model 调用 ensureIndexes：

```javascript
const schema = new Schema({
    ..
}, {
    autoIndex: false
});
const Clock = mongoose.model('Clock', schema);
Clock.ensureIndexes(callback);
```

**option：bufferCommands**

默认情况下，mongoose buffers会在连接中断时发出命令，直到驱动程序重新连接为止。若要禁用缓冲，请将bufferCommands设置为false。

```javascript
const schema = new Schema({
    ..
}, {
    bufferCommands: false
});
```

schema 的bufferCommands 会重写全局的 bufferCommands 选项。

```javascript
mongoose.set('bufferCommands',true);
const schema = new Schema({
    ..
}, {
    bufferCommands: false
});
```

**option：capped**

Mongoose 支持 MongoDB 的 capped collections ，要从底层把 collection 设定为 capped(封顶)，可以把collection 的最大容量设定到 `capped` 选项（单位 bytes）

```javascript
new Schema({
    ..
}, {
    capped: 1024
});
```

如果要传递多个选项，capped 也可以作为对象传递. 这个试试需要显式传入必要值 `size`

```javascript
new Schema({
    ..
}, {
    size: 1024,
    max: 1000,
    autoIndexId: true
})
```

**option：collection**

Mongoose 通过 utils.toCollectionName 方法，默认生成 collection 的名称（生成 model 名称的复数形式）。设置这个选项可以自定义名称

```javascript
const dataSchema = new Schema({
    ..
}, {
    collection: 'data'
});
```

**option：id**

Mongoose 会默认生成一个虚拟值 `id` ，指向文档的 `_id` 字段。如果你不需要 `id` 虚拟值，可以通过这个选项禁用此功能。

```javascript
// 默认行为
const schema = new Schema({
  name: String,
});
const Page = mongoose.model("Page", schema);
const p = new Page({
  name: "mongodb.org",
});
console.log(p.id); // 50341373e894ad16347efe01

//禁止 id
const schema = new Schema(
  {
    name: String,
  },
  {
    id: false,
  },
);
const Page = mongoose.model("Page", schema);
const p = new Page({
  name: "mongodb.org",
});
console.log(p.id); // undefined
```

**option：\_id**

Mongoose 默认给你的 Schema 赋值一个 `_id` ，这个值的类型是 ObjectId，这与 MongoDB 的默认表现一致。如果需要，可以禁止

此选项**只能**用于 subdocument。 Mongoose 不能保存没有id的文档，如果硬是要这么做，会报错。

```javascript
// 默认行为
const schema = new Schema({
  name: String,
});
const Page = mongoose.model("Page", schema);
const p = new Page({
  name: "mongodb.org",
});
console.log(p); // { _id: '50341373e894ad16347efe01', name: 'mongodb.org' }

// 禁止 _id
const schema = new Schema(
  {
    name: String,
  },
  {
    _id: false,
  },
);
const Page = mongoose.model("Page", schema);
const p = new Page({
  name: "mongodb.org",
});
console.log(p); // { name: 'mongodb.org' }
```

**option：minimize**

Mongoose 默认不保存空对象。

```javascript
const schema = new Schema({
  name: String,
  inventory: {},
});
const Character = mongoose.model("Character", schema);

const frodo = new Character({
  name: "Frodo",
  inventory: {
    ringOfPower: 1,
  },
});
Character.findOne(
  {
    name: "Frodo",
  },
  function (err, character) {
    console.log(character); // {name: 'Frodo', inventory: { ringOfPower: 1 }}
  },
);

const Sam = new Character({
  name: "Sam",
  inventory: {},
});
Character.findOne(
  {
    name: "Sam",
  },
  function (err, character) {
    console.log(character); // {name: 'Sam'}
  },
);
```

如果把 minimize 设定为 false, Mongoose 将保存空对象

```javascript
const Sam = new Character(
  {
    name: "Sam",
    inventory: {},
  },
  {
    minimize: false,
  },
);
Character.findOne(
  {
    name: "Sam",
  },
  function (err, character) {
    console.log(character); // {name: 'Sam',inventory:{}}
  },
);
```

**option：read**

```javascript
const schema = new Schema({
    ..
}, {
    read: 'primary'
}); // also aliased as 'p'
const schema = new Schema({
    ..
}, {
    read: 'primaryPreferred'
}); // aliased as 'pp'
const schema = new Schema({
    ..
}, {
    read: 'secondary'
}); // aliased as 's'
const schema = new Schema({
    ..
}, {
    read: 'secondaryPreferred'
}); // aliased as 'sp'
const schema = new Schema({
    ..
}, {
    read: 'nearest'
}); // aliased as 'n'
```

```javascript
const options = {
    replset: {
        strategy: 'ping'
    }
};
mongoose.connect(uri, options);

const schema = new Schema({
    ..
}, {
    read: ['nearest', {
        disk: 'ssd'
    }]
});
mongoose.model('JellyBean', schema);
```

**option：shardKey**

分片相关.

```javascript
new Schema({
    ..
}, {
    shardKey: {
        tag: 1,
        name: 1
    }
})
```

**option：strict**

Strict 选项默认为 true，这意味着你不能 `save` schema 里没有声明的属性。

```javascript
const thingSchema = new Schema({
    ..
})
const Thing = mongoose.model('Thing', thingSchema);
const thing = new Thing({
    iAmNotInTheSchema: true
});
thing.save(); // iAmNotInTheSchema is not saved to the db

// set to false..
const thingSchema = new Schema({
    ..
}, {
    strict: false
});
const thing = new Thing({
    iAmNotInTheSchema: true
});
thing.save(); // iAmNotInTheSchema is now saved to the db!!
```

`doc.set()` 也受该选项影响：

```javascript
const thingSchema = new Schema({
    ..
})
const Thing = mongoose.model('Thing', thingSchema);
const thing = new Thing;
thing.set('iAmNotInTheSchema', true);
thing.save(); // iAmNotInTheSchema is not saved to the db
```

这个值可以在 model 级别重写，在第二个参数值传入：

```javascript
const Thing = mongoose.model("Thing");
const thing = new Thing(doc, true); // enables strict mode
const thing = new Thing(doc, false); // disables strict mode
```

还可以将strict选项设置为“throw”，这将导致产生错误，而不是删除坏数据。

注意: 在 schema 中不存在的实例上设置的任何键/值总是被忽略，不管模式选项是什么。

```javascript
const thingSchema = new Schema({
    ..
})
const Thing = mongoose.model('Thing', thingSchema);
const thing = new Thing;
thing.iAmNotInTheSchema = true;
thing.save(); // iAmNotInTheSchema is never saved to the db
```

**option：strictQuery**

```javascript
const mySchema = new Schema(
  {
    field: Number,
  },
  {
    strict: true,
  },
);
const MyModel = mongoose.model("Test", mySchema);

// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`
MyModel.find({
  notInSchema: 1,
});
```

严格的选择适用于更新

```javascript
// Mongoose will strip out `notInSchema` from the update if `strict` is not `false`
MyModel.updateMany(
  {},
  {
    $set: {
      notInSchema: 1,
    },
  },
);
```

Mongoose 有一个单独的 strictQuery 选项，用于将过滤器参数的strict模式切换到查询。

```javascript
const mySchema = new Schema(
  {
    field: Number,
  },
  {
    strict: true,
    strictQuery: true, // Turn on strict mode for query filters
  },
);
const MyModel = mongoose.model("Test", mySchema);

// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`
MyModel.find({
  notInSchema: 1,
});
```

**option：toJSON**

与toObject选项完全相同，但仅在调用documents toJSON方法时才适用。

```javascript
const schema = new Schema({
  name: String,
});
schema.path("name").get(function (v) {
  return v + " is my name";
});
schema.set("toJSON", {
  getters: true,
  virituals: false,
});
const M = mongoose.model("Person", schema);
const m = new M({
  name: "Max Headroom",
});
m.toObject(); // {_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }
m.toJSON(); //  {_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }
JSON.stringfy(m); // { "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" }
```

**option：toObject**

Documents 的 toObject 方法可以把文档转换成一个 plain javascript object （也就是去掉里面的方法）。 这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。

例如要打印出虚拟值，可以向 `toObject` 传入 `{ getters: true }` ：

```javascript
const schema = new Schema({
  name: String,
});
schema.path("name").get(function (v) {
  return v + "is my name";
});
schema.set("toObject", {
  getters: true,
});
const M = mongoose.model("Person", schema);
const m = new M({
  name: "HAHA",
});
m; // { _id: 504e0cd7dd992d9be2f20b6f, name: 'HAHA is my name' }
```

**option：typekey**

类型声明

```javascript
const schema = new Schema({
  loc: {
    type: String,
    coordinates: [Number],
  },
});
```

对于像geoJSON这样的应用程序，“type”属性非常重要。控制使用哪个键mongoose来查找类型声明，要设置“typeKey”模式选项

```javascript
const schema = new Schema(
  {
    loc: {
      type: String,
      coordinates: [Number],
    },
    name: {
      $type: String,
    },
  },
  {
    typeKey: "$type",
  },
);
```

**option：validateBeforeSave**

默认情况下，文档在保存到数据库之前会自动验证。这是为了防止保存无效的文档。如果希望手动处理验证，并能够保存没有通过验证的对象，可以将validatebeforeave设置为false。

```javascript
const schema = new Schema({
  name: String,
});
schema.set("validateBeforeSave", false);
schema.path("name").validate(function (value) {
  return v != null;
});
const M = mongoose.model("Person", schema);
const m = new M({
  name: null,
});
m.validate(function (err) {
  console.log(err); // Will tell you that null is not allowed.
});
m.save(); // Succeeds despite being invalid
```

**option：versionKey**

`versionKey` 是 Mongoose 在文件创建时自动设定的。 这个值包含文件的内部[修订号](http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning)。 `versionKey` 是一个字符串，代表版本号的属性名， 默认值为 `__v` 。如果这个值与你的计划冲突，你可以设定为其他名称：

```javascript
const schema = new Schema({
    name: 'string'
});
const Thing = mongoose.model('Thing', schema);
const thing = new Thing({
    name: 'mongoose v3'
});
thing.save(); // { __v: 0, name: 'mongoose v3' }

// customized versionKey
new Schema({
    ..
}, {
    versionKey: '_somethingElse'
})
const Thing = mongoose.model('Thing', schema);
const thing = new Thing({
    name: 'mongoose v3'
});
thing.save(); // { _somethingElse: 0, name: 'mongoose v3' }
```

你也可以赋值为 `false` 禁用 `versionKey` 。

```javascript
const Schema({
    ..
}, {
    versionKey: false
});
const Thing = mongoose.model('Thing', schema);
const thing = new Thing({
    name: 'no versioning please'
});
thing.save(); // { name: 'no versioning please' }
```

**option：collation**

为 查询（query）和 聚合（aggregation）设置 collation

```javascript
const schema = new Schema({
    name: String
}, {
    collaction: {
        locale: 'en_US',
        strength: 1
    }
})

const MyModel = db.model('MyModel', schema);
myModel.create([{
            name: 'val',
            {
                name: 'Val'
            }]).then(function() {
            return MyModel.find({
                name: 'Val'
            });
        }).then(function(docs) {
            // docs 里面会包含上面两个值，因为 strength：1 代表着忽略大小写
        });
```

**option：skipVersioning**

跳过版本控制允许从版本控制中排除路径(例如。，即使更新了这些路径，也不会增加内部修订)。除非你知道你在做什么，否则不要这样做。对于子文档，使用完全限定路径将其包含在父文档中。

```javascript
new Schema({
    ..
}, {
    skipVersioning: {
        dontVersionMe: true
    }
});
thing.dontVersionMe.push('hey');
thing.save(); // version is not incremented
```

**option：timestamps**

如果设置了 `timestamps` 选项, mongoose 会在你的 schema 自动添加 `createdAt` 和 `updatedAt` 字段， 其类型为Date。这两个字段的默认名称是 `createAt` 和 `updateAt` ，你可以通过设定 `timestamps.createAt` 和 `timestamps.updateAt` 自定义名称。

```javascript
const thingSchema = new Schema({
    ..
}, {
    timestamps: {
        createdAt: 'created_at'
    }
});
const Thing = mongoose.model('Thing', thingSchema);
const thing = new Thing();
thing.save(); // `created_at` & `updatedAt` will be included
```

**option：useNestedStrict**

在 mongoose4 中， `update()` 和 `findOneAndUpdate()` 只检查顶层 schema 的严格模式设定。

```javascript
const childSchema = new Schema(
  {},
  {
    strict: false,
  },
);
const parentSchema = new Schema(
  {
    child: childSchema,
  },
  {
    strict: "throw",
  },
);
const Parent = mongoose.model("Parent", parentSchema);
Parent.update(
  {},
  {
    "child.name": "Luke Skywalker",
  },
  function (error) {
    // 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致
    // 子Schema的 `strict: false` 遭到无情忽视
  },
);

const update = {
  "child.name": "Luke Skywalker",
};
const opts = {
  strict: false,
};
Parent.update({}, update, opts, function (error) {
  // 这样可以，因为重写了父Schema的 strict 选项
});
```

如果你把 `useNestedStrict` 设为 true，mongoose 就不会忽略嵌套的 strict 设定。

```javascript
const childSchema = new Schema(
  {},
  {
    strict: false,
  },
);
const parentSchema = new Schema(
  {
    child: childSchema,
  },
  {
    strict: "throw",
    useNestedStrict: true,
  },
);
const Parent = mongoose.model("Parent", parentSchema);
Parent.update(
  {},
  {
    "child.name": "Luke Skywalker",
  },
  function (error) {
    // Works!
  },
);
```

### 模式类型（SchemaTypes）

SchemaTypes 是处理字段路径各种属性的定义（默认值、验证、getter、setter、查询的字段选择默认值，以及字符串和数字的其他一般特性）

下面是合法的 SchemaTypes：

- 'String'
- 'Number'
- 'Date'
- 'Buffer'
- 'Boolean'
- 'Mixed'
- 'ObjectId'
- 'Array'
- 'Decimal128'

例子：

```javascript
const schema = new Schema({
  name: String,
  binary: Buffer,
  living: Boolean,
  updated: {
    type: Date,
    default: Date.now,
  },
  age: {
    type: Number,
    min: 18,
    max: 65,
  },
  mixed: Schema.Types.Mixed,
  _someId: Schema.Types.ObjectId,
  decimal: Schema.Types.Decimal128,
  array: [],
  ofString: [String],
  ofNumber: [Number],
  ofDates: [Date],
  ofBuffer: [Buffer],
  ofBoolean: [Boolean],
  ofMixed: [Schema.Types.Mixed],
  ofObjectId: [Schema.Types.ObjectId],
  ofArrays: [[]],
  ofArrayOfNumbers: [[Number]],
  nested: {
    stuff: {
      type: String,
      lowercase: true,
      trim: true,
    },
  },
});

const Thing = mongoose.model("Thing", schema);
const m = new Thing();
m.name = "haha";
m.age = 125;
m.updated = new Date();
m.binary = new Buffer(0);
m.mixed = {
  any: {
    thing: "i want",
  },
};
m.markModified("mixed");
m._someId = new mongoose.Typed.ObjectId();
m.array.push(1);
m.ofString.push("strings!");
m.ofNumber.unshift(1, 2, 3, 4);
m.ofDates.addToSet(new Date());
m.ofBuffer.pop();
m.ofMixed = [
  1,
  [],
  "three",
  {
    four: 5,
  },
];
m.nested.stuff = "good";
m.save(callback);
```

#### SchemaType 选项

可以直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象

```javascript
const schema = new Schema({
  test: String,
});
const schema2 = new Schema({
  test: {
    type: String,
  },
});
```

除了 type 属性，还可以对这个字段路径指定其他属性，如果要在保存之前把字母都改成小写：

```javascript
const schema2 = new Schema({
  test: {
    type: String,
    lowercase: true,
  },
});
```

`lowercase` 属性只作用于字符串。以下有一些全部type 可用的选项和一些限定部分 type 使用的选项。

**全部可用**

- '`required`：布尔值或者函数，如果值为真，为此属性添加 required 验证器'
- '`default`：任何值或者函数设置此路径默认值，如果是函数，函数返回值为默认值'
- '`select`：布尔值执行query 默认 projections'
- '`validate`：属性验证函数'
- '`get`：函数 使用 `Object.defineProperty()` 定义自定义 getter'
- '`set`：函数 使用 `Object.defineProperty()` 定义自定义 setter'
- '`alias`：字符串 仅mongoose >= 4.10.0。 为该字段路径定义虚拟值 gets/sets'

```javascript
const numberSchema = new Schema({
  integerOnly: {
    type: Number,
    get: (v) => Math.round(v),
    set: (v) => Math.round(v),
    alias: "i",
  },
});

const Number = mongoose.model("Number", numberSchema);
const doc = new Number();
doc.integerOnly = 2.001;
doc.integerOnly; // 2
doc.i; // 2
doc.i = 3.001;
doc.integerOnly; //3
doc.i; //3
```

**索引相关**

可以使用 schema type 选项定义 MongoDB indexex

- '`index`: 布尔值 是否对这个属性创建索引'
- '`unique`: 布尔值 是否对这个属性创建唯一索引'
- '`sparse`: 布尔值 是否对这个属性创建稀疏索引'

```javascript
const schema = new Schema({
  test: {
    type: String,
    index: true,
    unique: true,
  },
});
```

String

- '`lowercase`: 布尔值 是否保存前对此值调用 `.toLowerCase()`'
- '`uppercase`: 布尔值 是否保存前对此值调用 `.toUpperCase()`'
- '`trim`: 布尔值 是否在保存前对此值调用 `trim()`'
- '`match`: 正则表达式 创建验证器检查这个值是否匹配给定正则表达式'
- '`enum`: 数组 创建验证器检查这个值是否包含于给定数组'

Number

- '`min`: 数值 创建验证器检查属性是否大于或者等于该值'
- '`max`: 数值 创建验证器检查属性是否小于或者等于该值'

Date

- '`min`: Date'
- '`max`: Date'

#### **使用注意**

**Dates**

内建的 Date 方法不会触发 mongoose 修改跟踪逻辑，如果使用 `setMonth()` 修改文档里面的 `Date` , mongoose 在 `doc.save()` 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库中。如果一定要用内建的 Date 方法，需要手动调用 `doc.markModified('pathToYourDate')` 告诉 mongoose 修改了数据。

```javascript
const Assignment = mongoose.model("Assignment", {
  dueDate: Date,
});
Assignment.findOne(function (err, doc) {
  doc.dueDate.setMonth(3);
  doc.save(callback); // 这个不会保存你的修改
  doc.markModified("dueDate");
  doc.save(callback);
});
```

**Mixed**

一个什么都可以放的 SchemaType, 虽然遍历，但是也会让数据难以维护。Mixed 可以通过 Schema. Types. Mixed 或者传入 一个空对象定义。下面三种方法效果是一致的。

```javascript
const Any = new Schema({
  any: {},
});
const Any = new Schema({
  any: Object,
});
const Any = new Schema({
  any: Schema.Types.Mixed,
});
```

因为这是个 schema-less type，所以可以赋值为任意类型，但是 mongoose 无法自动检测并保存修改。要告诉它修改了 Mixed type 的值，调用文档的 `.markModified(path)` 方法，传入你的 Mixed 字段路径

```javascript
person.anything = {
  x: [
    3,
    4,
    {
      y: "changed",
    },
  ],
};
person.markModified("anything");
person.save(); // anything will now get changed
```

**ObjectIds**

要指定类型为 ObjectId，在声明中使用 `Schema.Types.ObjectId`

```javascript
const mongoose = require("mongoose");
const ObjectId = mongoose.Schema.Types.ObjectId;
const Car = new Schema({
  driver: ObjectId,
});
```

**Arrays**

创造 SchemaTypes 或者子文档数组

```javascript
const ToySchema = new Schema({
    name: String
});
const ToyBox = new Schema({
    toys: [ToySchema],
    buffers: [Buffer],
    string: [String]，
    number: [Number]
});
```

注意：指定空数组相当于 `Mixed` , 下面的操作相当于创建 `Mixed` 数组：

```javascript
const Empty1 = new Schema({
    ary: {
    ]
}
});
const Empty2 = new Schema({
    any: Array
});
const Empty3 = new Schema({
    any: [Schema.Types.Mixed]
});
const Empty4 = new Schema({
    any: [{}]
});
```

数组的默认值是 `[]` （空数组）

```javascript
const Toy = mongoose.model("Test", toySchema);
new Toy().toys; // []
```

要手动把默认值设置为 `undefined` ，从而覆盖 `[]`

```javascript
const ToySchema = new Schema({
  toys: {
    type: [ToySchema],
    defalut: undefined,
  },
});
```

#### **创建自定义 Type**

Mongoose 可以扩展自定义 SchemaType.

** `schema.path()` 函数**

这个函数为给定字段路径返回实例化 schema type

```javascript
const sampleSchema = new Schema({
  name: {
    type: String,
    require: true,
  },
});
sampleSchema.path("name");
/**
 * SchemaString {
 *   enumValues: [],
 *   regExp: null,
 *   path: 'name',
 *   instance: 'String',
 *   validators: ...
 */
```

这个函数可以检查给定字段路径的检查器和类型等信息。

### 连接（Connections）

可以使用 `mongoose.connect()` 方法连接 MongoDB

```javascript
mongoose.connect("mongodb://localhost/myapp");
```

这是连接本地 `myapp` 数据库默认接口（27017）的最小配置。本地连接失败可以尝试 127.0.0.1.local hostname 被修改有时候会引起问题。

可以在 url 中指定多个参数：

```javascript
mongoose.connect("mongodb://username:password@host:port/database?options");
```

#### **操作缓存**

不必等等连接建立成功就可以使用 Mongoose models

```javascript
mongoose.connect("mongodb://localhost/myapp");
const MyModel = mongoose.model(
  "Test",
  new Schema({
    name: String,
  }),
);
MyModel.findOne(function (err, res) {
  // ...
});
```

Mongoose 会缓存 model 操作。这个操作很方便，但也会引起一些疑惑，因为如果没有连上的话，Mongoose 不会抛错。

```javascript
const MyModel = mongoose.model(
  "Test",
  new Schema({
    name: String,
  }),
);
MyModel.findOne(function (err, res) {
  // ..
});
setTimeout(function () {
  mongoose.connect("mongodb://localhost/xxx");
}, 6000);
```

要禁用缓存，修改 bufferCommands 配置。如果打开了这个选项连接被挂起，尝试关闭 bufferCommands 检查是否正确打开连接，也可以全局禁用 bufferCommands:

```javascript
mongoose.set("bufferCommands", false);
```

#### **选项**

`connect` 方法也接受 `options` 参数，这些参数会传入底层 MongoDB 驱动

```javascript
mongoose.connect(uri, options);
```

Mongoose 会不做修改直接把选项传到驱动，以下有一点例外

- '`bufferCommands` 是 mongoose 特有的选项，'
- '`user/pass` 用于认证的用户名和密码。mongoose 特有的，等价于 MongoDB 驱动的 `auth.user` 和 `auth.password`选项'
- '`autoIndex` 理想情况下，mongoose 在连接时会自动建立 schema 索引。这有利于开发，但是在大型生产环境中不是很理想，因为会导致性能下降。'
- '`dbName` 指定要连接的数据库名称（覆盖连接字符串）'

下面是一些重要的选项

- '`autoReconnect` 底层 MongoDB 驱动在连接后将自动重连。除非是管理连接池的高手，不然不建议设置为 false'
- '`bufferMaxEntries` MongoDB 驱动同样有自己的离线缓存机制。如果希望连接错误时终止数据库操作，可以设这个值为 0 以及把 bufferCommands 设为 false.'
- '`promiseLibrary` 设置底层 promise 库'
- '`poolSize` MongoDB 保持的最大 socket 连接数。默认是5. MongoDB 3.4 之前，只允许每个 socket 同时进行一个操作，所以如果有几个缓慢请求卡着后面快的请求，可以尝试增加连接数。'

举例子：

```javascript
const options = {
  useMongoClient: true,
  autoIndex: false, // 不要创建索引
  reconnectTries: Number.MAX_VALUE, // 不要停止重连
  reconnectInterval: 500, // 每500毫秒重连
  poolSize: 10, // 维护最多10个socket
  bufferMaxEntries: 0, // 如果没有连接，则立即返回错误，而不是等待重新连接
};
mongoose.connect(uri, options);
```

#### **回调**

`connect` 函数接受回调函数，或者返回一个 promise

```javascript
mongoose.connect(uri, options, function(error) {

});
mongoose.connect(uri, options).then(
    () => {
        /** ready to use. The `mongoose.connect()` promise resolves to undefined. */ }
    err => {
        /** handle initial connection error */ }
);
```

#### **连接字符串（Connectng String）选项**

可以在连接字符串填写驱动选项，这只适用于 MongoDB 驱动使用的选项，所以类似 bufferCommands 的 Mongoose 专用选项不能在连接字符串使用

```javascript
mongoose.connect(
  "mongodb://localhost:27017/test?connectTimeoutMS=1000&bufferCommands=false",
);
// 相当于
mongoose.connect("mongodb://localhost:27017/test", {
  connectTimeoutMS: 1000,
  // Note that mongoose will **not** pull `bufferCommands` from the query string
});
```

把选项放在连接字符串的劣势是不便阅读。优势是简短。最佳实践是把区分生产环境和开发环境的选项， `socketTimeoutMS` 、 `connectTimeoutMS` 放在 uri ， 把通用的常量如 `connectTimeoutMS` 、 `poolSize` 放在选项对象里。

#### **keepAlive注意事项**

对于长期运行的后台引用，启用毫秒级 `keepAlive` 是一个精明的操作。不这么做偶尔会经常收到看似没有什么原因的 `connection closed` 错误

```javascript
mongoose.connect(uri, {
  keepAlive: 120,
});
```

#### **副本集（Replica Set）连接**

要连接到副本集，可以使用逗号分隔开，传入多个地址：

```javascript
mongoose.connect('mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]' [, options]);
```

连接到单节点副本集，需要指定 `relicaSet` 选项

```javascript
mongoose.connect("mongodb://host1:port1/?replicaSet=rsName");
```

#### **多 mongos 支持**

使用高性能分片集群，需要连接[多个 mongos（MongoDB Shard） 实例](https://docs.mongodb.com/manual/reference/program/mongos/)。 在 mongoose 5.x 中， 你在连接多个 mongos 时[不需要传入任何特殊选项](http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster)。

```javascript
// Connect to 2 mongos servers
mongoose.connect("mongodb://mongosA:27501,mongosB:27501", cb);
```

#### **多个连接**

之前我们了解如何使用 Mongoose 默认连接方法连接到 MongoDB。但有时候我们需要权限不同的多个连接， 或是连接到不同数据库。这个情况下我们可以使用 `mongoose.createConnection()` ， 它接受之前提到的所有参数，给你返回一个新的连接。

```javascript
const conn = mongoose.createConnection(
  "mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]",
  options,
);
```

connection对象后续用于创建和检索models。 models 的范围总是局限于单个连接。

调用 `mongoose.connect()` 时，Mongoose 会自动创建**默认连接**。 你可以使用 `mongoose.connection` 访问默认连接。

#### **连接池**

无论是使用 `mongoose.connect` 或是 `mongoose.createConnection` 创建的连接， 都被纳入默认最大为 5 的连接池，可以通过 poolSize 选项调整：

```javascript
// With object options
mongoose.createConnection(uri, {
  poolSize: 4,
});

const uri = "mongodb://localhost/test?poolSize=4";
mongoose.createConnection(uri);
```

### 模型（Models）

Models 是从 Schema 编译来的构造函数，它们的实例就代表着可以从数据保存和读取 documents，从数据创建和读取 document 的所有操作都是通过 model 进行的。

```javascript
const schema = new Schema({
  name: "string",
  size: "string",
});
const Tank = mongoose.model("Tank", schema);
```

第一个参数是跟 model 对应的集合（collection） 名字的单数形式。Mongoose 会自动找到名称是 model 名字复数形式的 collection。对于上例，Tank 这个model 就对应 数据库中 tanks 这个 collection. `.model()` 这个函数是对 `schema` 做了拷贝（生成了model）。要确保在调用 `.model()` 之前把所有需要的东西都加进去 `schema` 里面。

#### **构造 documents**

Documents 是 model 的实例，创建它们并保存到数据库非常简单：

```javascript
const Tank = mongoose.model("Tank", yourSchema);
const small = new Tank({
  size: "small",
});
small.save(function (err) {
  if (err) return handleError(err);
});

Tank.create(
  {
    size: "small",
  },
  function (err, small) {
    if (err) return handleError(err);
  },
);
```

要注意，知道 model 使用的数据连接（connection）被打开，tanks 才会被创建/删除，每个 model 都有一个绑定的连接。如果model 是通过调用 `mongoose.model()` 生成的，它将使用 mongoose 的默认连接。

```javascript
mongoose.connect("localhost", "gettingstarted");
```

如果自行创建了连接，就需要使用 connection 的 `model` 函数代替 mongoose 的 `model` 函数

```javascript
const connection = mongoose.createConnection("mongodb://localhost:27017/test");
const Tank = connection.model("Tank", yourSchema);
```

#### **查询**

用 mongoose 查询文档相当容易，它支持 mongoDB的高级查询语法（rich），查询文档可以使用 `model` 的 find, findById, findOne, where 这些静态方法。

```javascript
Tank.find({
  size: "small",
})
  .where("createDate")
  .gt(oneYearAgo)
  .exec(callback);
```

#### **删除**

`model` 的 `remove` 方法可以删除所有匹配查询条件的文档

```javascript
Tank.remove(
  {
    size: "large",
  },
  function (err) {
    if (err) return handleError(err);
  },
);
```

#### **更新**

`model` 的 `update` 方法可以修改数据库中的文档，不过不会把文档返回给应用层。

如果想更新单独一条文档并且返回给应用层，可以使用 findOneAndIUpdate 方法

### 文档（Documents）

Mongoose documents代表着MongoDB 文档的一对一映射，每个 document 都是他的 Model 实例。

#### **检索**

MongoDB 有很多检索数据的方法。

#### **更新**

Document 更新的方法同样也有很多, 最基本的 findById

```javascript
Tank.findById(id, function (err, tank) {
  if (err) return handleError(err);
  tank.size = "large";
  tank.save(function (err, updateTank) {
    if (err) return handleError(err);
    res.send(updateTank);
  });
});
```

也可以用 `.set()` 修改 document 。在底层， `tank.size = 'large'` ，用 `tank.set({size:'large'})`

```javascript
Tank.findById(id, function (err, tank) {
  if (err) return handleError(err);
  tank.set({
    size: "large",
  });
  tank.save(function (err, updateTank) {
    if (err) return handleError(err);
    res.send(updateTank);
  });
});
```

这个方法先检索了数据，接着更新（使用了 `save` ）。如果我们仅仅需要更新而不是获取该数据， `model#update` 就很适合我们：

```javascript
Tank.update(
  {
    _id: id,
  },
  {
    $set: {
      size: "large",
    },
  },
  callback,
);
```

如果我们确实需要返回文档，下面的方法更加适合：

```javascript
Tank.findByIdAndUpdate(
  id,
  {
    $set: {
      size: "large",
    },
  },
  {
    new: true,
  },
  function (err, tank) {
    if (err) return handleError(err);
    res.send(tank);
  },
);
```

`findAndUpdate/Remove` 系列静态方法查找并返回最多1个文档，模式的方法有不少。

注意： `findAndUpdata/Remove` 不会修改数据库时执行任何钩子或者验证。可以使用 `runValidators` 选项获取一个验证的限制子集。但是需要钩子和全文档验证的，还是先query 在save

#### **验证**

Document 会在被保存之前验证。

#### **覆盖**

可以用 `.set()` 覆盖整个文档。如果要修改在中间件中被保存的文档，这样就很方便了。

```javascript
Tank.findById(id, function (err, tank) {
  if (err) return handleError();
  // otherTank 是 tank 的副本
  otherTank.set(tank);
});
```

### 子文档（Subdocuments）

子文档是指嵌套在另一个文档中的文档。在 Mongoose 中，这意味着可以在 里面嵌套一个 schema 。Mongoose 子文档有两种不同的概念：子文档数组和单个嵌套子文档。

```javascript
const childSchema = new Schema({
  name: "string",
});
const parentSchema = new Schema({
  children: [childSchema],
  // Single nested subdocuments. Caveat: single nested subdocs only work in mongoose >= 4.2.0
  child: childSchema,
});
```

子文档和普通 docuemnt 类似。嵌套 schema 可以有自己的中间件，自定义检索逻辑、虚拟值已经其他顶层 schemas 可用的特性，两者主要的不同点是子文档不能单独保存，他们会在他们的顶级文档保存时保存。

```javascript
const Parent = mongoose.model('Parent', parentSchema);
const parent = new Parent([children: [{
    name: 'Matt'
}, {
    name: 'Sarah'
}]]);
parent.children[0].name = 'HaHa';
// parent.children[0].save() 无操作，虽然他触发了中间件，但是没有保存文档，需要 save 他的文档、
parent.save(callback);
```

子文档跟普通文档一样有 save 和 validate 中间件，调用福文档的 save 会触发所有子文档的 save 中间件， validate 中间件同理。

```javascript
childSchema.pre("save", function (next) {
  if ("invalid" == this.name) {
    return next(new Error("#sadpanda"));
  }
  next();
});
const parent = new Parent({
  children: [
    {
      name: "invalid",
    },
  ],
});
parent.save(function (err) {
  console.log(err.message); //#sadpanda
});
```

子文档的 `pre('save')` 和 `pre('validate')` 中间件执行于顶层 document `pre('save')` 之前，顶层 document 的 `pre('validate')` 之后。因为 `save()` 前的验证就是一个中间件。

```javascript
const childSchema = new mongoose.Schema({
  name: "string",
});
childSchema.pre("validate", function (next) {
  console.log(2);
  next();
});
childSchema.pre("save", function (next) {
  console.log(3);
  next();
});
const parentSchema = new mongoose.Schema({
  child: childSchema,
});

parentSchema.pre("validate", function (next) {
  console.log(1);
  next();
});
parentSchema.pre("save", function (next) {
  console.log(4);
  next();
});

// 1 2 3 4
```

#### **查找子文档**

每个子文档都有一个默认 `_id` ，Mongoose document 数组有一个特别的 id 方法，这个方法只要传入 `_id` 就能返回文档数组中特定文档。

```javascript
const doc = parent.children.id(_id);
```

#### **添加子文档到数组**

Mongoose 数组方法有 push、unshift、addToSet 等等：

```javascript
const Parent = mongoose.model("Parent");
const parent = new Parent();

parent.children.push({
  name: "Haha",
});
const subdoc = parent.children[0];
subdoc; //  _id: '501d86090d371bab2c0341c5', name: 'Haha' }
subdoc.isNew; // true

parent.save(function (err) {
  if (err) return handleError(err);
  console.log("Success");
});
```

create 方法可以新建文档但是不加入数组

```javascript
const newdoc = parent.children.create({
  name: "Haha",
});
```

#### **删除子文档**

每个子文档都有 remove 方法，另外，对于子文档数组，有一个等效的方法 `.pull()` 。对于单个嵌套子文档，remove 与把这个文档的值设为 null 等效。

```javascript
// 等效 parent.children.pull(_id)
parent.children.id(_id).remove();
// 或者 parent.child = null
parent.child.remove();
parent.save(function (err) {
  if (err) return handleError(err);
  console.log("the subdocs were removed");
});
```

**代替声明语法的写法**

如果用对象的数组创建 schema, mongoose 会自动把对象转成 schema：

```javascript
const parentSchema = new Schema({
  children: [
    {
      name: "string",
    },
  ],
});
// 等价于
const parentSchema = new Schema({
  children: [
    new Schema({
      name: "string",
    }),
  ],
});
```

### 查询（queries）

Model 的多个静态辅助方法都可以查询文档。

Model 的方法中包含查询条件参数的（find findById count update）都可以按照下面两种方式执行：

1. 传入 callback 参数，操作会被立即执行，查询结果被传给回调函数（callback）
2. 不传 callback 参数，Query 的一个实例（一个 query对象）被返回，这个 query 提供了 构建查询器的特殊接口。

Query 实例有一个 `.then()` 函数，用法类似 promise

如果执行查询时传入 callback, 就需要用 JSON 文档的格式指定查询条件，JSON 文档的语法跟 MongoDB shell 一致。

```javascript
const Parent = mongoose.model("Person", mySchema);

// 查询 last name 是 haha 的 person,选中 name 和 occupation 字段
Person.findOne(
  {
    "name.last": "haha",
  },
  "name occupation",
  function (err, person) {
    if (err) return handleError(err);
    console.log(person.name.first, person.name.last, person.occupation);
  },
);
```

上面的查询被立即执行，查询结果被传入回调函数。Mongoose 中所有的调用函数都是用 `callback(error,result)` 这种模式。如果查询发生错误， `error` 参数即是错误文档， `result` 参数会是 null。如果查询成功， `error` 参数是 null， `result` 即是查询结果。

查询结果的格式取决于做什么操作：findOne() 是单个文档（或者null），find() 是文档列表，count() 是文档数量， update() 是被修改的文档数量。

下面看看不传入 callback 这个参数会是怎么样的：

```javascript
// 查找每个  last name 是 haha 的 person
const query = Person.findOne({
  "name.last": "haha",
});
// 选择 name 和 occupation 字段
query.select("name occupation");

// 然后执行查询
query.exec(function (err, person) {
  if (err) return handleError(err);
  console.log(person.name.first, person.name.last, person.occupation);
});
```

上面的代码中，query 是 Query 类型的变量，Query 能够用链式语法构建查询器，无需要执行 JSON 对象。下面2个实例等效：

```javascript
Person.find({
  occupation: /host/,
  "name.last": "haha",
  age: {
    $gt: 17,
    $lt: 66,
  },
  likes: {
    $in: ["vaporizing", "talking"],
  },
})
  .limit(10)
  .sort({
    occupation: -1,
  })
  .select({
    name: 1,
    ouccupation: 1,
  })
  .exec(callback);

Person.find({
  occupation: /host/,
})
  .where("name.last")
  .equals("haha")
  .where("age")
  .gt(17)
  .lt(66)
  .where("likes")
  .in(["vaporizing", "talking"])
  .limit(10)
  .sort("-occupation")
  .select("name occupation")
  .exec(callback);
```

#### **引用其他文档**

MongoDB 中没有表连接，但引用其他结合的文档有时候也会需要。population 就是这样当升的。

**Streaming**

可以用 流式处理 MongoDB 的查询结果，需要调用 Query.cursor() 函数获得 QueryCursor 的一个实例：

```javascript
const cursor = Person.find({
  occupation: /host/,
}).cursor();

cursor.on("data", function (doc) {
  /**Called once for every document*/
});
cursor.on("close", function () {
  /**Called when done*/
});
```

### 验证（validation）

需要先注意下面几点：

- '验证定义于 SchemaType'
- '验证是一个中间件，它默认作为 `pre(save)`钩子注册在 schema 上'
- '可以使用 `doc.validate(callback)`或者 `doc.validateSync()`手动验证'
- '验证器不对未定义的值进行验证，唯一例外就是 require 验证器'
- '验证是异步递归的。当调用 Model#save, 子文档也会执行，出错的话 Model#save 回调会接受错误'
- '验证是可以定制的。'

```javascript
const schema = new Schema({
  name: {
    type: String,
    require: true,
  },
});
const Cat = db.model("Cat", schema);

const cat = new Cat();
cat.save(function (err) {
  assert.equal(error.errors["name"].message, "Path `name` is required.");
  error = cat.validateSync();
  assert.equal(error.errors["name"].message, "Path `name` is required.");
});
```

#### **内建 Validators**

Mongoose 有一些内建验证器

- '所有 SchemaTypes 都有内建的 required 验证器。required 验证器使用 `checkRequired（）`函数判定这个值是否满足 required 验证器'
- 'Numbers 有 min 和 max 验证器'
- 'String 有 enum、match、maxlength 和 minlength 验证器'

上面的链接提供了使用和错误处理相关的详细信息。

```javascript
const breakfastSchema = new Schema({
  eggs: {
    type: Number,
    min: [6, "Too few eggs"],
    max: 12,
  },
  bacon: {
    type: Number,
    required: [true, "Why no bacon"],
  },
  drink: {
    type: String,
    enum: ["Coffee", "Tea"],
    required: function () {
      return this.bacon > 3;
    },
  },
});
const Breakfast = db.model("Breakfast", breakfastSchema);
const badBreakfast = new Breakfast({
  eggs: 2,
  bacon: 0,
  drink: "Milk",
});

const error = badBreakfast.validateSync();
assert.equal(error.errors["eggs"].message, "Too few eggs");
assert.ok(!error.errors["bacon"]);
assert.equal(
  error.errors["drink"].message,
  "`Milk` is not a valid enum value for path `drink`",
);
badBreakfast.bacon = 5;
badBreakfast.drink = null;

error = badBreakfast.validateSync();
assert.equal(error.errors["drink"].message, "Path `drink` is required");

badBreakfast.bacon = null;
error = badBreakfast.validateSync();
assert.equal(error.errors["bacon"].message, "Why no bacon");
```

#### ** `unique` 不是验证器**

它是构建 MongoDB unique indexes 的辅助函数

```javascript
const uniqueUsernameSchema = new Schema({
  username: {
    type: String,
    unique: true,
  },
});
const U1 = db.model("U1", uniqueUsernameSchema);
const U2 = db.model("U2", uniqueUsernameSchema);
const dup = [
  {
    username: "Val",
  },
  {
    username: "val",
  },
];

U1.create(dup, function (err) {});

// 在保存之前需要等待索引完成构建，否则可能会违反惟一的约束。
U2.once("index", function (err) {
  assert.ifError(err);
  U2.create(dup, function (err) {
    // 重复键错误
    assert.ok(err);
    assert.ok(!err.errors);
    assert.ok(error.message.indexOf("duplicate key error") != -1);
  });
});

U2.init().then(function () {
  U2.create(dup, function (err) {
    // 重复键错误
    assert.ok(err);
    assert.ok(!err.errors);
    assert.ok(error.message.indexOf("duplicate key error") != -1);
  });
});
```

#### **自定义验证器**

如果内建检验器不够用了，可以定义满足自己需要的验证器

自定义验证器通过传入一个验证函数来定义

```javascript
const userSchema = new Schema({
  phone: {
    type: String,
    validate: {
      validator: function (v) {
        return /\d{3}-d{3}-d{4}/.test(v);
      },
      message: "{VALUE} is not a valid phone number!",
    },
    required: [true, "User phone number required"],
  },
});

const User = db.model("user", userSchema);
const user = new User();
let error;

user.phone = "555.0123";
error = user.validateSync();
assert.equal(
  error.errors["phone"].message,
  "555.0123 is not a valid phone number!",
);

user.phone = "";
rror = user.validateSync();
assert.equal(error.errors["phone"].message, "User phonse number required!");

user.phone = "201-555-0123";
rror = user.validateSync();
assert.equal(error, null);
```

#### **异步自定义验证器**

自定义验证器可以是异步的，如果检验函数返回 promise (像 `async` 函数)，mongoose 将会等待该 promise 完成。如果更喜欢使用回调函数，设置 `isAsync` 选项，mongoose 会将回调函数作为验证函数的第二个参数。

```javascript
const userSchema = new Schema({
  name: {
    type: String,
    // 可以通过返回一个promise使验证器异步。如果返回一个promise，不要指定' isAsync '选项。
    validate: function (v) {
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          resolve(false);
        }, 5);
      });
    },
  },
  phone: {
    type: String,
    validate: {
      isAsync: true,
      validator: function (v, cb) {
        setTimeout(function () {
          const phoneRegex = /\d{3}-d{3}-d{4}/;
          const msg = v + "is not a valid phone number!";
          // 第一个参数是布尔值代表验证结果
          // 第二个参数是报错信息
          cb(phoneRegex.test(v), msg);
        }, 5);
      },
      // 默认报错信息会被 cb 的第二个参数覆盖
      message: "Default error message",
    },
    required: [true, "User phone number required"],
  },
});

const User = db.model("User", userSchema);
const user = new User();
let error;
user.phone = "555.0123";
user.name = "test";
user.validate(function (error) {
  assert.ok(error);
  assert.equal(
    error.errors["phone"].message,
    "555.0123 is not a valid phone number!",
  );
  assert.equal(
    error.errors["name"].message,
    "Validator failed for path `name` with value `test`",
  );
});
```

#### **验证错误**

验证失败返回 的err 包含一个 `ValidatorError` 对象。每一个 ValidatorError 都有 kind、path、value 和 message 属性。ValidatorError 也有可能有 reason 属性如果验证器抛出错误，这个属性会包含该错误原因。

```javascript
const toySchema = new Schema({
    color: String,
    name: String
});

const validator = function(v) {
    return /red|white|gold/i.test(v);
}

toySchema.path('color'）.validate(validator, 'Color `{VALUE}` not valid', 'Invalid color'); toySchema.path('name').validate(function(v) {
            if (v !== 'Turbo Man') {
                throw new Error('Need to get a Turbo Man for Christmas');
            }
            return ture;
        }, 'Name `{VALUE}` is not valid');

        const Toy = db.model('Toy', toySchema);
        const toy = new Toy({
            color: 'Green',
            name: 'Power Ranger'
        }); toy.save(function(err) {
            assert.equal(err.errors.color.message, 'Color `Green` not valid');
            assert.equal(err.errors.color.kind, 'Invalid color');
            assert.equal(err.errors.color.path, 'color');
            assert.equal(err.errors.color.value, 'Green');
            assert.equal(err.errors.name.message, 'Need to get a Turbo Man for Christmas');
            assert.equal(err.errors.name.value, 'Power Ranger');
            assert.equal(err.errors.name.reason.message, 'Need to get a Turbo Man for Christmas');
            assert.equal(err.name, 'ValidationError');
        });
```

#### **嵌套对象中的 Required 验证器**

定义嵌套对象的验证器需要特别注意

```javascript
let personSchema = new Schema({
  name: {
    first: String,
    last: String,
  },
});

assert.throws(function () {
  // 这里会报错，因为 name 不是完整路径
  personSchema.path("name").required(true);
});

// 要让嵌套对象 required 要使用单独的嵌套 schema
const nameSchema = new Schema({
  name: {
    type: nameSchema,
    required: true,
  },
});

personSchema = new Schema({
  name: {
    type: nameSchema,
    required: true,
  },
});

const person = db.model("Person", personSchema);
const person = new Person();
const error = person.validateSync();
assert.ok(error.errors["name"]);
```

#### **Update 验证器**

Mongoose 还支持验证 update() 和 findOneAndUpdate() 操作，Update 验证器默认关闭，如果需要打开，需要配置 runValidators

```javascript
const toySchema = new Schema({
  color: String,
  name: String,
});

const Toy = db.model("Toys", toySchema);

Toy.schema.path("color").validate(function (value) {
  return /blue|green|white|red|orange|periwinkle/i.test(value);
}, "Invalid color");

const opts = {
  runValidators: true,
};
Toy.update(
  {},
  {
    color: "bacon",
  },
  opts,
  function (err) {
    assert.equal(err.errors.color.message, "Invalid color");
  },
);
```

#### **Update 验证器 与 `this` **

update 验证器和 document 验证器有很多不同。上面的颜色验证函数，this 指向验证中的 document，然后update 验证器运行时，被更新文档不一定存在于服务器内存，所以 this 值未定义

```javascript
const toySchema = new Schema({
  color: String,
  name: String,
});

toySchema.path("color").validate(function (value) {
  // 在运行“validate()”或“validateSync()”时
  // 验证器可以使用“this”访问文档。
  if (this.name.toLowerCase().indexOf("red") !== -1) {
    return value !== "red";
  }
  return true;
});

const Toy = db.model("ActionFigure", toySchema);

const toy = new Toy({
  color: "red",
  name: "Red Power Ranger",
});
const error = toy.validateSync();
assert.ok(error.errors["color"]);

const update = {
  color: "red",
  name: "Red Power Ranger",
};
const opts = {
  runValidators: true,
};

Toy.update({}, update, opts, function (error) {
  // The update validator throws an error:
  // "TypeError: Cannot read property 'toLowerCase' of undefined",
  // because `this` is **not** the document being updated when using
  // update validators
  assert.ok(error);
});
```

#### ** `context` 选项**

context 选项运行把 update 验证器的 this 设定为 query

```javascript
toySchema.path("color").validate(function (v) {
  // When running update validators with the `context` option set to
  // 'query', `this` refers to the query object.
  if (this.getUpdate().$set.name.toLowerCase().indexOf("red") !== -1) {
    return value == "red";
  }
  return true;
});

const Toy = db.model("Figure", toySchema);
const update = {
  color: "blue",
  name: "haha",
};
// Note the context option
const opts = {
  runValidators: true,
  context: "query",
};
Toy.update({}, update, opts, function (error) {
  assert.ok(error.errors["color"]);
});
```

#### **Update 验证器字段路径**

另一个关键不同点是 update 验证器只运行于更新的字段。 下例中，因为 'name' 在更新操作未被指定，所以此次更新操作成功。

使用 update 验证器的时候， `required` 验证器**只会**在你对某个字段显式使用 `$unset` 才会触发。

```javascript
const kittenSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  age: Number,
});

const Kitten = db.model("Kitten", kittenSchema);

const update = {
  color: "blue",
};
const opts = {
  runValidators: true,
};
Kitten.update({}, update, opts, function (err) {
  // 即使 'name' 没有指定也操作成功了
});

const unset = {
  $unset: {
    name: 1,
  },
};
Kitten.update({}, unset, opts, function (err) {
  // 'name' required， 操作失败
  assert.ok(err);
  assert.ok(err.errors["name"]);
});
```

#### **Update 验证器只运行于指定字段路径**

最后要注意的是：update 验证器**只**运行于下列更新操作：

- '`$set`'
- '`$unset`'
- '`$push` (>= 4.8.0)'
- '`$addToSet` (>= 4.8.0)'
- '`$pull` (>= 4.12.0)'
- '`$pullAll` (>= 4.12.0)'

例如，以下 update 成功执行，不管 `number` 的值，因为 update 验证器 无视 `$inc` 。同样， `$push` 、 `$addToSet` 、 `$pull` 和 `$pullAll` 验证器 不会对数组自身验证，只会对数组中的元素验证。

```javascript
const testSchema = new Schema({
  number: {
    type: Number,
    max: 0,
  },
  arr: [
    {
      message: {
        type: String,
        maxlength: 10,
      },
    },
  ],
});

// Update 验证器不会作检查，所以你再仍然可以 `$push` 两个元素到数组
// 只要他们的 `message` 没有超长
testSchema.path("arr").validate(function (v) {
  return v.length < 2;
});

const Test = db.model("Test", testSchema);

const update = {
  $inc: {
    number: 1,
  },
};
const opts = {
  runValidators: true,
};
Test.update({}, update, opts, function (error) {
  // 这里不会报错
  update = {
    $push: [
      {
        message: "hello",
      },
      {
        message: "world",
      },
    ],
  };
  Test.update({}, update, opts, function (error) {
    // 这里也不会报错
  });
});
```

#### **\$push 和 \$addToSet**

4.8.0 新特性： update 验证器也运行于 `$push` 和 `$addToSet`

```javascript
const testSchema = new Schema({
  numbers: [
    {
      type: Number,
      max: 0,
    },
  ],
  docs: [
    {
      name: {
        type: String,
        required: true,
      },
    },
  ],
});

const Test = db.model("TestPush", testSchema);

const update = {
  $push: {
    numbers: 1,
    docs: {
      name: null,
    },
  },
};
const opts = {
  runValidators: true,
};
Test.update({}, update, opts, function (error) {
  assert.ok(error.errors["numbers"]);
  assert.ok(error.errors["docs"]);
});
```

### 中间件（middleware）

中间件（pre 和 post）是在异步函数执行时函数传入的控制函数。中间件在 Schema 上指定，在写插件时很有用。Mongoose 4.x 有四种中间件：document、model、aggregate、query 中间件。对于 document 中间件，this 指向当前的 document，Document 中间件支持下面的 document 操作：

- 'init'
- 'validate'
- 'save'
- 'remove'

对于 query中间件，this 指向 query。Query 中间件支持一下 Model 和 Query 操作：

- 'count'
- 'find'
- 'findOne'
- 'findOneAndRemove'
- 'findOneAndUpdate'
- 'update'

Aggregate 中间件作用于 MyModel.aggregat(), 它会在对 aggregate 对象调用 exec() 时执行。对于 aggregate 中间件，this 也是指向 aggregation 对象。

- 'aggregate'

对于 model 中间件来说，this 是指向当前的model. Model 中间件支持下面的操作：

- 'insertMany'

所有的中间件支持 pre 和 post 钩子，下面解释这两个钩子的细节。

注意：Query 是没有 remove 钩子的，只有 document有，如果设定了 remove 钩子，将会在调用 myDoc.remove()而不是MyModel.remove 的时候触发。只有 create() 函数会触发 save() 钩子。

#### **Pre**

pre 钩子分为串行和并行两种。

**串行**

串行中间件一个接一个地执行，具体来说，上一个中间件调用 next 函数的时候，下一个执行。

```javascript
const schema = new Schema({
    ..
});

schema.pre('save', function(next) {
    next();
});
```

在 5.x 版本中，除了手动调用 next ，可以返回一个 promise ，甚至是 async/await。

```javascript
schema.pre("save", function () {
  return doStuff().then(() => doMoreStuff());
});
// 或者 Node.js >= 7.6.0:
schema.pre("save", async function () {
  await doStuff();
  await doMoreStuff();
});
```

next() 不会阻止剩余代码的运行，可以使用提前 return 模式来阻止 next () 后面的代码。

```javascript
const schema = new Schema({
    ..
});
schema.pre('save', function(next) {
    if (foo()) {
        console.log('calling next');
        // `return next();` will make sure the rest of this function doesn't run
        next();
    }
    // Unless you comment out the `return` above, 'after next' will print
    console.log('after next');
});
```

**并行**

并行中间件提供细粒度流控制

```javascript
const schema = new Schema({
    ..
});
// true 代表这是一个并行中间件，如果要使用并行中间件，必须指定 true 为第二个参数
schema.pre('save', true, function(next, done) {
    next();
    setTimeout(done, 100);
});
```

上述的例子中，save 方法将在所有中间件都调用了 done 的时候才会执行。

使用场景：

中间件对原子化模型逻辑很有帮助，这里有一些其他建议：

- '复杂的数据校验'
- '删除依赖文档（删除用户后删除其他所有文章）'
- '某个操作触发的异步任务'

错误处理：

如果 pre 钩子出错，momgoose 将不会执行后面的函数。Mongoose 会向回调函数传入 err 参数，或者 reject 返回的 promise 。下面是几个错误的处理的方法:

```javascript
schema.pre("save", function (next) {
  const err = new Error("something went gone");
  next(err);
});

schema.pre("save", function (next) {
  return new Promise((resolve, reject) => {
    reject(new Error("something went gone"));
  });
});

schema.pre("save", async function () {
  await Promise.resolve();
  throw new Error("something went gone");
});

myDoc.save(function (err) {
  console.log(err.message);
});
```

多次调用 next 是无效的，如果调用 next 带有错误参数 err1 ，然后再抛出一个 err2，mongoose 只会传递 err1

#### **Post中间件**

post 中间件在方法执行之后调用，这个时候每个 pre 中间件都已经完成了。

```javascript
schema.post("init", function (doc) {
  console.log("%s has been initialized from the db", doc._id);
});
schema.post("validate", function (doc) {
  console.log("%s has been validated (but not saved yet)", doc._id);
});
schema.post("save", function (doc) {
  console.log("%s has been saved", doc._id);
});
schema.post("remove", function (doc) {
  console.log("%s has been removed", doc._id);
});
```

#### **异步 Post 钩子**

如果给回调函数传入两个参数，mongoose 会认为第二个参数 next 函数，可以通过 next 触发下一个中间件

```javascript
schema.post("save", function (doc, next) {
  setTimeout(function () {
    console.log("post1");
    next();
  }, 10);
});
// 直到第一个中间件执行 next() 才会执行
schema.post("save", function (doc, next) {
  console.log("post2");
  next();
});
```

#### **Save/Validate钩子**

save() 函数触发 validate 钩子，mongoose validate() 其实就是 pre('save')钩子，这意味着所有 pre('validate') 和 post('validate')都会在 pre('save')钩子之前调用。

```javascript
schema.pre("validate", function () {
  console.log("this gets printed first");
});

schema.post("validate", function () {
  console.log("this gets printed second");
});

schema.pre("save", function () {
  console.log("this gets printed third");
});

schema.post("save", function () {
  console.log("this gets printed fourth");
});
```

#### **finAndUpdate() 与 Query 中间件使用注意**

pre 和 post save() 钩子都不执行于 update , findOneAndUpdate 等情况。Mongoose4.0 为这些函数制定了新钩子。

```javascript
schema.pre('find', function() {
    console.log(this instanceof mongoose.Query); // true
    this.start = Date.now()
});

schema.post('find', function(result) {
            console.log(this instanceof mongoose.Query); // true
            // prints returned documents
            console.log('find() returned ' + JSON.stringify(result));
            // prints number of milliseconds the query took
            console.log('find() took ' + (Date.now() - 'this.start) + '
                millis ');'
            });
```

Query 中间件不同于 document 中间件，document 中间件中，this 指向被更新 document, query 中间件中，this 指向query 对象而不是被更新 document

例如，如果要每次 update 之前更新 updateAt 时间戳，可以使用 pre 钩子

```javascript
schema.pre("update", function () {
  this.update(
    {},
    {
      $set: {
        updateAt: new Date(),
      },
    },
  );
});
```

#### **错误处理中间件**

错误处理中间件比普通中间件多一个 `error` 参数，并且 `err` 作为第一个参数传入。 而后错误处理中间件可以让你自由地做错误的后续处理。

```javascript
const schema = new Schema({
  name: {
    type: String,
    // // Will trigger a MongoError with code 11000 when you save a duplicate
    unique: true,
  },
});

// 处理函数必须传入3个参数：发生的错误，返回文件，以及 next 函数
schema.post("save", function (error, doc, next) {
  if (error.name === "MongoError" && error.code === 11000) {
    next(new Error("There was a duplicate key error"));
  } else {
    next(error);
  }
});

// Will trigger the `post('save')` error handler
Person.create([
  {
    name: "Axl Rose",
  },
  {
    name: "Axl Rose",
  },
]);
```

对于query 中间件也可以使用错误处理，可以定义一个 post update 钩子，它可以捕获 MongoDB 重复 key 错误。

```javascript
schema.post("update", function (error, res, next) {
  if (error.name === "MongoError" && error.code === 11000) {
    next(new Error("There was a duplicate key error"));
  } else {
    next(error);
  }
});

const people = [
  {
    name: "Axl Rose",
  },
  {
    name: "Axl Rose",
  },
];
Person.create(people, function (error) {
  Person.update(
    {
      name: "haha",
    },
    {
      $set: {
        name: "Axl Rose",
      },
    },
    function (error) {
      // error.message` will be "There was a duplicate key error"
    },
  );
});
```

### 填充（Populate）

像sql 里面的 join 的聚合操作，populate 可以让你在别的 collection 中引用 document

Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。我们可以填充单个或者每个 document、单个或者多个纯对象，甚至是 query 返回的一切对象。

```javascript
const mongoose = require("mongoose");
const Schema = mongoose.Schema;
const personSchema = Schema({
  _id: Schema.Types.ObjectId,
  name: String,
  age: Number,
  stories: [
    {
      type: Schema.Types.ObjectId,
      ref: "Story",
    },
  ],
});

const storySchema = Schema({
  author: {
    type: Schema.Types.ObjectId,
    ref: "Person",
  },
  title: String,
  fans: [
    {
      type: Schema.Types.ObjectId,
      ref: "Person",
    },
  ],
});

const Story = mongoose.model("Story", storySchema);
const Person = mongoose.model("Person", personSchema);
```

上面创建了两个 Model，Person model 的 stories 字段设为 ObjectId 数组。ref 选项告诉 Mongoose 在填充的时候使用哪个 model，上例中为 Story 的 model. 所有存储在此的 \_id 必须是 Story model 中的 document 的 \_id。

注意：ObjectId、Number、String 以及 Buffer 都可以作为 refs 使用。但是最好还是用 ObjectId

#### **保存 refs**

保存 refs 与保存普通属性一样，把 \_id 的值赋给它就好了：

```javascript
const author = new Person({
  _id: new mongoose.Types.ObjectId(),
  name: "Ian Fleming",
  age: 50,
});

author.save(function (err) {
  if (err) return handleError(err);

  var story1 = new Story({
    title: "Casino Royale",
    author: author._id, // assign the _id from the person
  });

  story1.save(function (err) {
    if (err) return handleError(err);
    // thats it!
  });
});
```

#### **Population**

我们做的东西还是跟平时差不多，只是创建了 `Person` 和 `Story` 。现在试试对query 填充 story 的 author。

```javascript
Story.findOne({
  title: "haha",
})
  .population("author")
  .exec(function (err, story) {
    if (err) return handleError(err);
    console.log("The author is %s", story.author.name);
  });
```

被填充的字段已经不再是原来的 \_id，而是被指定的 document 替代，这个 document 由另一条 query 从数据库返回。refs 数组的原理也是相似的。对 query 对象调用 populate 方法，就能返回装载对应 \_id 的 document 数组。

#### **设置被填充字段**

```javascript
Story.findOne(
  {
    title: "Casino Royale",
  },
  function (error, story) {
    if (error) {
      return handleError(error);
    }
    story.author = author;
    console.log(story.author.name); // prints "Ian Fleming"
  },
);
```

#### **字段选择**

如果我们只需要填充 document 其中一部分字段，第二个参数传入 field name syntax 就可以实现。

```javascript
Story.findOne({
  title: /casino royale/i,
})
  .populate("author", "name") // only return the Persons name
  .exec(function (err, story) {
    if (err) return handleError(err);
    console.log("The author is %s", story.author.name); // The author is Ian Fleming
    console.log("The author is %s", story.author.age); // The authors age is null
  });
```

#### **填充多个字段**

```javascript
Story.
find(...).
populate('fans').
populate('author').
exec();
```

如果对同一路径 populate 两次，只有最后一次生效。

```javascript
// 第二个会覆盖第一个的
Story.find()
  .populate({
    path: "fans",
    select: "name",
  })
  .populate({
    path: "fans",
    select: "email",
  });
// The above is equivalent to:
Story.find().populate({
  path: "fans",
  select: "email",
});
```

#### **Query 条件与其他选项**

如果要根据年龄来填充，只填充 name, 并且值返回最多5个数据

```javascript
Story.
find(...).
populate({
    path: 'fans',
    match: {
        age: {
            $gte: 21
        }
    },
    // Explicitly exclude `_id`, see http://bit.ly/2aEfTdB
    select: 'name -_id',
    options: {
        limit: 5
    }
}).
exec();
```

#### **Refs 到 children**

我们发现，用 author 对象没有办法获取 story 列表，因为 author.stories 没有被 pushed 任何 story 对象

我们希望 author 知道哪些 story 属于他们，通常，schema 应该通过在 多 的一方使用指向它们的父节点（parent pointer）解决一对多关系问题。另一方面，如果有充分理由得到指向子节点的数组，可以像下面代码一样把 document push() 到数组中。

```javascript
author.stories.push(story1);
author.save(callback);
```

然后我们就能 find 和 populate 了

```javascript
Person.findOne({
  name: "Ian Fleming",
})
  .populate("stories")
  .exec(function (err, person) {
    if (err) throw handleError(err);
    console.log(person);
  });
```

如果父子节点互相指向，数据可能会在某一时刻失去同步。为此我们可以不使用填充，直接 `find()` 我们需要的 story

```javascript
Story.find({
  author: author._id,
}).exec(function (err, stories) {
  if (err) return handleError(err);
  console.log("The stories are an array: ", stories);
});
```

query 填充后返回的 document 功能齐全，除非设置 lean 选项，否则它就是可 remove，可 save 的。调用 remove 不单是从数组中删除也是从数据库中删除它们。

#### **填充现有 document**

document#populate()

#### **填充多个现有 document**

如果需要填充一个或者多个 document 对象，我们可以使用 Model.populate 方法。

#### **多级填充**

假设 user schema 记录了 user 的 friends

```javascript
const userSchema = new Schema({
  name: String,
  friends: [
    {
      type: ObjectId,
      ref: "User",
    },
  ],
});
```

当然可以填充得到用户的 friends 列表，但是如果要在获得他们朋友的朋友呢？指定 `populate` 选项就可以了

```javascript
User.findOne({
  name: "Val",
}).populate({
  path: "friends",
  populate: {
    path: "friends",
  },
});
```

#### **跨数据库填充**

假设现在有 event schema 和 conversation schema, 每个 event 对应一个 conversation 线程

```javascript
const eventSchema = new Schema({
  name: String,
  conversation: ObjectId,
});
const conversationSchema = new Schema({
  numMessage: Number,
});
```

并且，event 和 conversation 保存在不同的 MongoDB 实例中

```javascript
const db1 = mongoose.createConnection("localhost:27000/db1");
const db2 = mongoose.createConnection("localhost:27001/db2");

const Event = db1.model("Event", eventSchema);
const Conversation = db2.model("Conversation", conversationSchema);
```

这个情况就**不能**直接使用 `populate()` 了，因为 `populate()` 不知道应该使用什么填充。 可以显式指定一个 model

```javascript
Event.find()
  .population({
    path: "conversation",
    model: Conversation,
  })
  .exec(function (err, docs) {});
```

#### **动态引用**

Mongoose 也可以从多个 collection 填充。假设 user schema 有一系列 connection，一个 user 可以连接到其他 user 或者组织。

```javascript
const userSchema = new Schema({
  name: String,
  connection: [
    {
      kind: String,
      item: {
        type: ObjectId,
        refPath: "connections.kind",
      },
    },
  ],
});
const organizationSchema = new Schema({
  name: String,
  kind: String,
});

const User = mongoose.model("User,userSchema");
const Organization = mongoose.model("Organization", organizationSchema);
```

上面的 `refPath` 属性意味着 mongoose 会查找 `connections.kind` 路径， 以此确定 `populate()` 使用的 model。换句话说， `refPath` 属性可以让你动态寻找 `ref` 。

### 鉴别器（Discriminators）

Discriminator 是一种 schema 继承机制。它允许在相同的底层 MongoDB collection 上使用部分重叠的 schema 建立多个 model。

假设要在单个 collection 中记录多种 event ，每个 event 都有时间戳字段，但是 click 事件还有 URL 字段，可以用 model.discriminator 实现上面的要求。这个函数需要两个参数，model 名称和 discriminator schema, 返回 model 结合原 model 的 schema 和 discriminator schema.

```javascript
const options = {
  discriminatorKey: "kind",
};
const eventSchema = new mongoose.Schema(
  {
    tiem: Date,
  },
  options,
);
const Event = mongoose.model("Event".eventSchema);

// ClickedLinkEvent 是一个有 URL 的特别 event
const ClickedLinkEvent = Event.discriminator(
  "ClickedLink",
  new mongoose.Schema(
    {
      url: String,
    },
    options,
  ),
);

// 当你创建通用 event，他将没有 URL 字段...
const genericEvent = new Event({
  time: Date.now(),
  url: "google.com",
});
assert.ok(!genericEvent.url);

// 但是 ClickedLinkEvent 可以有
const clickedEvent = new ClickedLinkEvent({
  time: Date.now(),
  url: "google.com",
});
assert.ok(clickedEvent.url);
```

#### **Discriminator 储存在 Event model 的 collection**

现在假设你要创建另一个 discriminator，记录用户注册 event。 `SignedUpEvent` 实例将跟 通用 events 和 `ClickedLinkEvent` 实例 一样储存在同一个 collection。

```javascript
const event1 = new Event({
  time: Date.now(),
});
const event2 = new ClickedLinkEvent({
  time: Date.now(),
  url: "google.com",
});
const event3 = new SignedUpEvent({
  time: Date.now(),
  user: "testuser",
});

const save = function (doc, callback) {
  doc.save(function (error, doc) {
    callback(error, doc);
  });
};

async.map([event1, event2, event3], save, function (error) {
  Event.count({}, function (error, count) {
    assert.equal(count, 3);
  });
});
```

#### **Discriminator keys**

Mongoose 通过 'discriminator key' 识别两个不同的 discriminator， 这个值默认是 `__t` 。Mongoose 自动在你的 schema 添加 `__t` 字段， 记录你的 document 是哪个 discriminator 的实例。

```javascript
const event1 = new Event({
  time: Date.now(),
});
const event2 = new ClickedLinkEvent({
  time: Date.now(),
  url: "google.com",
});
const event3 = new SignedUpEvent({
  time: Date.now(),
  user: "testuser",
});

assert.ok(!event1.__t);
assert.equal(event2.__t, "ClickedLink");
assert.equal(event3.__t, "SignedUp");
```

#### **Discriminator 在查询中添加 discriminator key**

Discriminator model 的特别之处在于：他们会把 discriminator key 附到 query 上。换句话说， `find()` , `count()` , `aggregate()` 等方法 都能适配 discriminators。

```javascript
const event1 = new Event({
  time: Date.now(),
});
const event2 = new ClickedLinkEvent({
  time: Date.now(),
  url: "google.com",
});
const event3 = new SignedUpEvent({
  time: Date.now(),
  user: "testuser",
});

const save = function (doc, callback) {
  doc.save(function (error, doc) {
    callback(error, doc);
  });
};

async.map([event1, event2, event3], save, function (error) {
  ClickedLinkEvent.find({}, function (error, docs) {
    assert.equal(docs.length, 1);
    assert.equal(docs[0]._id.toString(), event2._id.toString());
    assert.equal(docs[0].url, "google.com");
  });
});
```

#### **Discriminator 复制 pre / post 钩子**

Discriminator 会继承他的基础 schema 的 pre 和 post 中间件。 不过，你也可以为 discriminator 添加中间件，这不回影响到基础 schema。

```javascript
const options = {
  discriminatorKey: "kind",
};

const eventSchema = new mongoose.Schema(
  {
    time: Date,
  },
  options,
);
const eventSchemaCalls = 0;
eventSchema.pre("validate", function (next) {
  ++eventSchemaCalls;
  next();
});
const Event = mongoose.model("GenericEvent", eventSchema);

const clickedLinkSchema = new mongoose.Schema(
  {
    url: String,
  },
  options,
);
const clickedSchemaCalls = 0;
clickedLinkSchema.pre("validate", function (next) {
  ++clickedSchemaCalls;
  next();
});
const ClickedLinkEvent = Event.discriminator(
  "ClickedLinkEvent",
  clickedLinkSchema,
);

const event1 = new ClickedLinkEvent();
event1.validate(function () {
  assert.equal(eventSchemaCalls, 1);
  assert.equal(clickedSchemaCalls, 1);

  const generic = new Event();
  generic.validate(function () {
    assert.equal(eventSchemaCalls, 2);
    assert.equal(clickedSchemaCalls, 1);
  });
});
```

#### **处理自定义 \_id 字段**

Discriminator 的字段是基础 schema 加 discriminator schema ， 并且以 discriminator schema 的字段优先。 但有一个例外， `_id` 字段。

You can work around this by setting the `_id` option to false in the discriminator schema as shown below.

```javascript
const options = {
  discriminatorKey: "kind",
};

// 基础 schema 有字符串格式的 `_id` 字段和 Data 格式的 `time` 字段...
const eventSchema = new mongoose.Schema(
  {
    _id: String,
    time: Date,
  },
  options,
);
const Event = mongoose.model("BaseEvent", eventSchema);

const clickedLinkSchema = new mongoose.Schema(
  {
    url: String,
    time: String,
  },
  options,
);
// 但是 Discriminator schema 有字符串格式的 `time`，并且有
// 隐式添加的 ObjectId 格式的 `_id`
assert.ok(clickedLinkSchema.path("_id"));
assert.equal(clickedLinkSchema.path("_id").instance, "ObjectID");
const ClickedLinkEvent = Event.discriminator(
  "ChildEventBad",
  clickedLinkSchema,
);

const event1 = new ClickedLinkEvent({
  _id: "custom id",
  time: "4pm",
});
// 问题来了，clickedLinkSchema 重写了 `time` 路径，但是**没有**
// 重写 `_id` 路径，因为已经隐式添加（没看懂）
assert.ok(typeof event1._id === "string");
assert.ok(typeof event1.time === "string");
```

#### **discriminator 与 `Model.create()` **

当你使用 `Model.create()` ，Mongoose 会自动帮你适配 discriminator key ~

```javascript
const Schema = mongoose.Schema;
const shapeSchema = new Schema(
  {
    name: String,
  },
  {
    discriminatorKey: "kind",
  },
);

const Shape = db.model("Shape", shapeSchema);

const Circle = Shape.discriminator(
  "Circle",
  new Schema({
    radius: Number,
  }),
);
const Square = Shape.discriminator(
  "Square",
  new Schema({
    side: Number,
  }),
);

const shapes = [
  {
    name: "Test",
  },
  {
    kind: "Circle",
    radius: 5,
  },
  {
    kind: "Square",
    side: 10,
  },
];
Shape.create(shapes, function (error, shapes) {
  assert.ifError(error);
  // 重点看这里
  assert.ok(shapes[0] instanceof Shape);
  assert.ok(shapes[1] instanceof Circle);
  assert.equal(shapes[1].radius, 5);
  assert.ok(shapes[2] instanceof Square);
  assert.equal(shapes[2].side, 10);
});
```

#### **数组中的嵌套 discriminator**

你也可以为嵌套文档数组定义 discriminator。 嵌套 discriminator 的特点是：不同 discriminator 类型储存在相同的文档而不是同一个 mongoDB collection。 换句话说，嵌套 discriminator 让你 在同一个数组储存符合不同 schema 的子文档。

最佳实践：确保你声明了钩子再使用他们。 你**不应当**在调用 `discriminator()` 之后调用 `pre()` 或 `post()`

```javascript
const eventSchema = new Schema(
  {
    message: String,
  },
  {
    discriminatorKey: "kind",
    _id: false,
  },
);

const batchSchema = new Schema({
  events: [eventSchema],
});

// `batchSchema.path('events')` gets the mongoose `DocumentArray`
const docArray = batchSchema.path("events");

// 这个 `events` 数组可以包含 2 种不同的 event 类型，
// 'clicked' event that requires an element id that was clicked...
const clickedSchema = new Schema(
  {
    element: {
      type: String,
      required: true,
    },
  },
  {
    _id: false,
  },
);
// 确定在调用 `discriminator()` **之前**
// 对 `eventSchema` 和 `clickedSchema` 赋予钩子
const Clicked = docArray.discriminator("Clicked", clickedSchema);

// ... and a 'purchased' event that requires the product that was purchased.
const Purchased = docArray.discriminator(
  "Purchased",
  new Schema(
    {
      product: {
        type: String,
        required: true,
      },
    },
    {
      _id: false,
    },
  ),
);

const Batch = db.model("EventBatch", batchSchema);

// Create a new batch of events with different kinds
const batch = {
  events: [
    {
      kind: "Clicked",
      element: "#hero",
      message: "hello",
    },
    {
      kind: "Purchased",
      product: "action-figure-1",
      message: "world",
    },
  ],
};

Batch.create(batch)
  .then(function (doc) {
    assert.equal(doc.events.length, 2);

    assert.equal(doc.events[0].element, "#hero");
    assert.equal(doc.events[0].message, "hello");
    assert.ok(doc.events[0] instanceof Clicked);

    assert.equal(doc.events[1].product, "action-figure-1");
    assert.equal(doc.events[1].message, "world");
    assert.ok(doc.events[1] instanceof Purchased);

    doc.events.push({
      kind: "Purchased",
      product: "action-figure-2",
    });
    return doc.save();
  })
  .then(function (doc) {
    assert.equal(doc.events.length, 3);

    assert.equal(doc.events[2].product, "action-figure-2");
    assert.ok(doc.events[2] instanceof Purchased);

    done();
  })
  .catch(done);
```

#### **检索数组中的嵌套 discriminator**

检索嵌套 discriminator

```javascript
const singleEventSchema = new Schema(
  {
    message: String,
  },
  {
    discriminatorKey: "kind",
    _id: false,
  },
);

const eventListSchema = new Schema({
  events: [singleEventSchema],
});

const subEventSchema = new Schema(
  {
    sub_events: [singleEventSchema],
  },
  {
    _id: false,
  },
);

const SubEvent = subEventSchema
  .path("sub_events")
  .discriminator("SubEvent", subEventSchema);
eventListSchema.path("events").discriminator("SubEvent", subEventSchema);

const Eventlist = db.model("EventList", eventListSchema);

// Create a new batch of events with different kinds
const list = {
  events: [
    {
      kind: "SubEvent",
      sub_events: [
        {
          kind: "SubEvent",
          sub_events: [],
          message: "test1",
        },
      ],
      message: "hello",
    },
    {
      kind: "SubEvent",
      sub_events: [
        {
          kind: "SubEvent",
          sub_events: [
            {
              kind: "SubEvent",
              sub_events: [],
              message: "test3",
            },
          ],
          message: "test2",
        },
      ],
      message: "world",
    },
  ],
};

Eventlist.create(list)
  .then(function (doc) {
    assert.equal(doc.events.length, 2);

    assert.equal(doc.events[0].sub_events[0].message, "test1");
    assert.equal(doc.events[0].message, "hello");
    assert.ok(doc.events[0].sub_events[0] instanceof SubEvent);

    assert.equal(doc.events[1].sub_events[0].sub_events[0].message, "test3");
    assert.equal(doc.events[1].message, "world");
    assert.ok(doc.events[1].sub_events[0].sub_events[0] instanceof SubEvent);

    doc.events.push({
      kind: "SubEvent",
      sub_events: [
        {
          kind: "SubEvent",
          sub_events: [],
          message: "test4",
        },
      ],
      message: "pushed",
    });
    return doc.save();
  })
  .then(function (doc) {
    assert.equal(doc.events.length, 3);

    assert.equal(doc.events[2].message, "pushed");
    assert.ok(doc.events[2].sub_events[0] instanceof SubEvent);

    done();
  })
  .catch(done);
```

###
