---
title: '正则表达式'
date: '2019-06-25  09:30:54'
slug: 'RegExp'
tags: '正则表达式'
categories:
  - '正则表达式'
---

最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex-1.htm)，再结合 JS 中的[正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)进行复习。

## 正则表达式

### 定义

编写处理字符串的程序或者网页时候，经常会有查找符合复杂规则的字符串的需要。正则表达式就是用于描述这些规。即记录文本规则的代码。

### 入门

在一篇英文小说中查找 `hi` ，可以使用正则 `hi` 。它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 `h` ，后一个字符串是 `i` 。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，可以匹配 `hi` 、 `HI` 、 `Hi` 、 `hI` 这四种情况中的任意的一种。

`hi` 这个正则表达式也会匹配 `him` 、 `history` 、 `high` 等，如果要精确查找到 `hi` 这个单词的话，应该使用正则表达式 `\bhi\b` 。

`\b` 是正则表达式规定一个特殊代码（元字符），代表着单词的开头或者结尾，也就是单词的分界处。英文的单词一般是由空格，标点符号或者换行符来分隔的，但是 `\b` 并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。

如果要找到是 `hi` 后面不远处跟着一个 `Lucy` ，就要使用正则表达式 `\bhi\b.*\bLucy\b` 。这里的 `.` 是一个元字符，匹配除了换行符外的任意字符。 `*` 同样是元字符，不过它代表的不是字符，也不是位置。而是数量，它指定 `*` 前边的内容可以连续重复使用任意次以使整个正则表达式得到匹配。因此 `.*` 连在一起就意味着任意数量的不包括换行的字符。现在 `\bhi\b.*\bLucy\b` 的意思就是：先是一个单词 `hi` ，然后是任意个任意字符（但不能是换行），最后是 `Lucy` 整个单词。

如果使用其他元字符，可以构造更强大的正则表达式，比如下面的例子

```perl
0\d\d-\d\d\d\d\d\d\d\d
# 以 0 开头，然后是两个数字，然后是一个连字符'-'，最后是8个数字（也就是中国的电话号码，只能匹配区号是3位的情况）
# \d 是一个新的元字符。匹配一个数字。'-'不是元字符，只匹配它本身——连字符（或者减号，或者中横线等）

# 简化
0\d{2}-d{8}
# \d 后面{2} 和 {8}的意思必须连续重复匹配2（8）次
```

### 元字符

常用的元字符

| 代码 | 说明 | 相当于 |
| ---- '| ------------------------------------------------------------ | ------ |'
| `.` | 匹配换行符以外的任意字符 | |
| `\w` | 匹配字母或数字或下划线或汉字 | |
| `\s` | 匹配任意的空白符（包括空格、制表符（Tab）、换行符，中文全角空格） | |
| `\d` | 匹配数字 | |
| `\b` | 匹配单词的开始或者结束 | |
| `^` | 匹配字符串的开始 | |
| `$` | 匹配字符串的结束 | |

元字符 `^` 和 `$` 都匹配一个位置，这和 `\b` 有点类似。 `^` 匹配想要用来查找的字符串的开头， `$` 匹配结尾。

`\d+` 匹配1个或者更多连续的数字。 `+` 是和 `*` 类似的元字符，不同的是 `*` 匹配重复任意次（可能是0次），而 `+` 则匹配重复1次或者更多次。

`\b\w{6}\b` 匹配刚好 6个字符的单词

`\d{5,12}` 表示匹配字符串里面包含 5 到 12 连续位数字，而不是整个字符串是 5 到 12 位数字

`^\d{5,12}$` 则是精确匹配整个字符串就是 5 到 12 位数字

### 字符转义

如果想要查找元字符本身的话，比如查找 `.` 或者 `*` 就需要转义， `\` 可以来取消这些字符的特殊意义

```perl
# 查找 .
\.

# 查找 *
\*

# 查找 \
\\

```

### 重复

下面是正则表达式中所有限定符（指定数量的代码）

| 代码/语法 | 说明 |
| --------- '| ----------------- |'
| \* | 重复0次或者更多次 |
| + | 重复1次或者更多次 |
| ？ | 重复0次或者1次 |
| {n} | 重复n次 |
| {n, } | 重复n次或更多次 |
| {n, m} | 重复n次到m次 |

`Windows\d+` 匹配 `Windows ` 后面跟1个或者跟多数字

`^\w+` 匹配一行的第一个单词（或者整个字符串的第一个单词）

### 字符类

要想查找数字、字母或者数字，空白是很简单的，因为已经有对应的这些字符集合的元字符，但是想匹配没有预定字符的字符集合（比如元音字母 `a` / `e` / `i` / `o` / `u` ）。

只需要在方括号中列出它们就可以了, `[aeiou]` 就匹配任何一个英文元音字母， `[.?!]` 匹配标点符号（ `.` 或 `?` 或 `!` ）

也可以轻松指定一个字符范围， `[0-9]` 的含义和 `\d` 是完全一致的：一个数字。

`[a-z0-9A-Z]` 也完全等同于 `\w` （如果值考虑英文的话）

思考：

`\(?0\d{2}[) -]?\d{8}`

上面的表达式，可以匹配几种格式的电话号码，像（010）88888888，或者010-88888888。它首先是一个转义字符，它能出现0次或者1次（？）, 然后是一个0，后面跟着两个数字（d{2}），然后是 `）` 或者 `-` 或者空格中的一个，它出现1次或者不出现，最后是8个数字。

### 分枝条件

上面思考题，其实也可以匹配 010)8888888或者 （010-88888888 这样不正确的格式。要解决这个问题，需要用到分枝条件。正则表达式里面的分枝条件是有几种规则的。如果满足其中任意一个规则应该都当成匹配，具体的方法是用 `|` 把不同的规则都分隔开。

```perl
0\d{2}-\d{8}|0\d{3}-d{7}
# 这个表达式可以匹配两种连字符分隔的电话号码：一种是三位区号的，8位本地号。另一种是4位区号的，7个本地号的
\(0\d{2}\)[- ']?\d{8}|0\d{2}[- ]?\d{8}'
# 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。可以试试用分支条件把这个表达式扩展成支持4位区号的
\d{5}-\d{4}|\d{5}
# 这个表达式用于匹配美国的邮政编码。它的规则是5位数字，或者用连字号间隔的9位数字。
# 这要需要注意，不能改成 \d{5}|\d{5}-d{4}，这样就只会匹配5位邮编（以及9位邮编的前5位）。原因是匹配分支条件时，会从左到右测试每个条件，如果满足了某个分支的话，就不会去管其他条件了。
```

### 分组

重复单个字符，直接在字符后面加上限定符就好了。如果想要重复多个字符的话，可以用小括号来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了，或者是其他的操作。

```perl
（\d{1,3}\.){3}\d{1,3}
# 上面是一个简答的 ip地址匹配。\d{1,3}匹配1到3位数字
# (\d{1,3}\.){3}匹配三位数字加上一个英文句号，这个整体也是这个分组重复了3次，最后再加上一个1到3位的数字 \d{1,3}
# 缺漏的地方在于它也会匹配 256.300.899.999 这种不存在的ip 地址。
# 正确的地址(ip地址中每个数字都不能大于255，可以有前导0)
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
```

### 反义

有时候需要查找的不是某个能简单定义的字符类的字符。比如想查找除了数字以外的，其他任意字符都行的情况，这时候就需要反义。

| 代码/语法 | 说明 |
| ---------- '| -------------------------------------------- |'
| `\W` | 匹配任意不是字母、数字、下划线或者汉字的字符 |
| `\S` | 匹配任意不是空白符的字符 |
| `\D` | 匹配任意不是数字的字符 |
| `\B` | 匹配不是单词开头或者结束的位置 |
| `[^X]` | 匹配除了 X 以外的任意的字符 |
| `[^aeiou]` | 匹配除了 aeiou 这个字母与以外的任意字符 |

例子：

`\S+` 匹配不包括空白符的字符串

`<a[^>]+>` 匹配用尖括号括起来的以 `a` 开头的字符串

### 后向引用

使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或者其他程序中作进一步的处理。默认情况下，每个分组都会自动拥有一个组号，规则就是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，依次类推。

分组0代表整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的，第一遍只给未命名组分配，第二遍只给命名组分配，因为所有命名组的组号都大于未命名的组号。

可以使用 `(?:exp)这样的语法来剥夺一个分组对组号分配的参与权`

后向引用，用于重复搜索前面的某个分组匹配的文本。例如， `\1` 代表分组1匹配的文本。

```perl
\b(\w+)\b\s+\1\b
# 匹配重复的单词，这个表达式首先是一个单词，也就是单词开始处和单词结束处之间多于一个的字母或者数字（\b(\w+)\b），这个单词会被捕获到编码为1的分组中，然后是1个或者几个空白符(\s+)，最后分组1中捕获的内容（也就是前面匹配的那个单词）（\1）
```

也可以自己指定子表达式的组名，要指定一个子表达式的组名，使用这样的语法:

`(?<Word>\w+)` 或者 `(?'Word'\w+)` 这样就把 `\w` 的组名指定为 Word。要反向引用这个分组捕获的内容，可以使用 `\k<Word>` ，上面的例子也可以写成这样：

```perl
\b(?<Word>\w+)\b\s+\k<Word>\b
```

下表是常用分组语法：

| 分类 | 代码/语法 | 说明 |
| -------- '| ------------- | ------------------------------------------------------------ |'
| 捕获 | (exp) | 匹配 exp, 并捕获文本到自动命名的组里 |
| | (?\<name>exp) | 匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 `(?'name'exp)` |
| | (?:exp) | 匹配 exp，不捕获匹配的文本，也不给此分组的分配组号 |
| 零宽断言 | (?= exp) | 匹配 exp 前面的位置 |
| | (?<= exp) | 匹配 exp 后面的位置 |
| | (?!exp) | 匹配后面跟的不是 exp 的位置 |
| | (?<!exp) | 匹配前面不是 exp 的位置 |
| 注释 | (?#comment) | 这种类型的分组不对正则表达式的处理产生任何影响，用于注释让人阅读 |

### 零宽断言

断言用来声明一个应该为真的事实，正则表达式中只有当断言为真的时候才会继续进行匹配。

用于查找在某些内容前或者之后的东西，像 `\b` 、 `^` 、 `$` 那样用于指定一个位置，这个位置应该满足一定的条件（断言），因此它们被称为零宽断言。

`(?=exp)` 也叫零宽度正预测先行断言（Zero-width positive lookahead），它断言自身出现的位置的后面能匹配表达式 exp。比如， `\b\w+(?=ing\b)` ，匹配以 `ing` 为结尾的单词的前面部分（除了 ing 以外的部分），如查找 `I'm singing while you're dancing.` 时，它会匹配 `sing` 和 `danc`

`(?<=exp)` 也叫零宽度正回顾后发断言(Zero-width positive lookbehind)，它断言自身出现的为位置的前面能匹配表示达 exp，比如 `(?<=\bre)\w+\b` 会匹配以 `re` 开头的单词的后半部分（除了re 以外的部分）。例如在查找 `reading a book` 时，它匹配 `ading` 。

假如想要给一个很长的数字中每三位加一个逗号，从右边加。可以这样查找前面和里面添加逗号的部分：

```perl
((?<=\d)\d{3})+\b
# 查找 1234567890 => 234567890

（?<=\s）\d+(?=\s)
# 匹配以空白符间隔的数字，不包括这些空白符
# 查找 1234 56 7890 => 56
```

### 负向零宽断言

前面提到怎么查找不是某个字符或者不在某个字符类里面的字符的方法（反义）。但是如果我们只是想确保某个字符没有出现，但不想去匹配它时，例如查找这样的单词——它里面的出现了字母q, 但是q后面跟着的不是字母 u，我们可以尝试：

```perl
\b\w*q[^u]\w*\b
# 匹配包含后面不是字母u 的字母q的单词。但是你可以发现 [^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]总要匹配一个字符，或者是句号或者是其他的什么。后面的 \w*\b 将会匹配下一个单词，于是 上面的表达式就可以匹配整个  Iraq fighting。
# 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。
\b\w*q(?!u)\w*\b
```

零宽度负预测先行断言(?!exp)(Zero-width negative lookahead)，断言此位置后面不能匹配表达式exp。

例如：

```perl
\d{3}(?!\d)
# 匹配三位数字，而且这三位数字的后面不能是数字
\b((?!abc)\w)+\b
# 匹配不包括连续字符串 abc 的单词
```

同理可以用零宽度负回顾后发断言(?<!exp)(Zero-width negative lookbehind)，来断言此位置的前面不能匹配表达式 `(?<![a-z])\d{7}` , 即前面不是小写字母的七位数字

一个更加复杂的例子：

`(?<=<(\w+)>).*(?=<\/\1>)`

匹配不包含属性的简单 html 标签内的内容。 `(?<=<(\w+)>)` 指定了这样的前缀：被尖括号括起来的单词，然后是 `.*` (任意的字符串)，最后一个是后缀 ` (?=<\/\1>)` 。 `\/` 转义了， `\1` 反向引用，整个内容就是闭合标签之间的内容，不包括两个标签本身。

### 注释

小括号的另一种用途是通过语法 `(?#comment)` 来包含注释。

例如：

```
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
```

要包含注释的话，最好是启用“忽略模式里面的空白符”选项。这样在编写表达式时能任意的添加空格/TAB/换行，而实际使用时这些都被忽略。启用这个选项后，在 `#` 后面到这一行结束的所有文本都被当做注释忽略掉。例如，我们可以前面的一个表达式写成这样：

```perl
(?<=	# 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或者数字（即HTML/XML标签）
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个 '/'，后面是先前捕获的标签
)       # 后缀结束
```

### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例子：a.\*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 `aabab` 的话，它就会匹配整个 `aabab` ，这被称为贪婪匹配。

有时候，我们需要懒惰匹配，也就是尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 `?` 。这样， `.?` 这意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

`a.*?b` 匹配最短的，以a开始，以b结束的字符串。如果把它应用于 `aabab` 的话，它会匹配 `aab` 和 `ab`

| 代码/语法 | 说明 |
| --------- '| ---------------------------------- |'
| `*?` | 重复任意次，但尽可能少重复 |
| `+?` | 重复 1次或者更多次，但尽可能少重复 |
| `??` | 重复 0 次或者 1 次，但尽可能少重复 |
| `{n,m}？` | 重复 n 到 m 次，但尽可能少重复 |
| `{n,}?` | 重复 n 次以上，但尽可能少重复 |

## JS 中的正则表达式

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，这些模式被用于 `RegExp` 的 `test` 和 `exec` ，以及 `String` 的 `match` 、 `replace` 、 `search` 和 `split` 方法。

### 创建一个正则表达式

1. 使用一个正则表达式字面量，其由包含斜杠之间的模式组成：

```javascript
const regex = /ab+c/;
const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;
```

2. 调用`RegExp`对象的构造函数：

```javascript
let regex = new RegExp('ab+c');
let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, 'gi');
let regex = new RegExp('^[a-zA-Z]+[0-9]*\\W?_$', 'gi');
```

### 编写一个正则表达式的模式

一个正则表达式的模式由简单的字符所构成，比如 `/abc/` ，或是简单和特殊字符的组合，比如 `/ab*c/` 或者 `/Chapter(\d+)\.\d*/` 。后者用到了括号，它在正则表达中可以被当作是一个记忆设备。这一部分正则所匹配的字符会被记住，在后面可以利用。

**使用简单的模式**

简单的模式由找到的直接匹配所构成的。

```javascript
/abc/;
// 匹配 Hi, do you know your abc's?
// 匹配 The latest airplane designs evolved from slabcraft.?
// 不匹配 Grab crab
```

**使用特殊字符**

```javascript
/ab*c/;
// 匹配 cbbabbbbcdebc => abbbbc
```

| 字符 | 含义 |
| --------- '| ------------------------------------------------------------ |'
| `\` | 在非特殊字符之前的反斜杆表示下一个字符是特殊的。<br>反斜杆也可以将其后的特殊字符，转义为字面量。<br>使用 `new RegExp('pattern')` 的时候要将 `\` 转义，因为 `\` 在字符串里面也是一个转义字符 |
| `^` | 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 |
| `$` | 匹配输入的结束。如果多行标识符被设置为 true，那么也会匹配换行符之前的位置。0 |
| `*` | 匹配前一个表示0 次或者多次。等价于 `{0,}` |
| `+` | 匹配前面一个表达式1次或者更多次，等价于 `{1,}` |
| `?` | 匹配前面一个表达式0次或者1次。等价于 `{0,1}` <br>如果紧跟在任何量词 `*` 、 `+` 、 `?` 、 `{}` 后面，将会使得量词变成非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反 |
| `.` | （小数点）匹配除换行符之外面的任何单个字符 |
| `(x)` | 匹配 ‘x’并记住匹配项。括号被称为捕获括号。<br>模式 `/(foo)(bar)\1\2/` <br>在正式表达式的替换环节，使用 `$1` 的语法，例如 `'bar.foo'.replace(/(..)(..)/,'$2$1')` |
| `(?:x)` | 匹配‘x’但不记住匹配项。这种叫做非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。<br> |
| `x(?=y)` | 匹配‘x’仅仅当'x'后面跟着‘y’。这种叫先行断言。<br> `/Jack(?=Spart)/` 会匹配到 ‘Jack’仅当它后面跟着'Spart'。但是‘Spart’都不是匹配结果中的一部分 |
| `(?<=y)x` | 匹配‘x’仅仅当'x'前面是‘y’, 这种叫做后行断言。<br> `/(?<=Jack)Spart/` 会匹配到 ‘Spart’仅仅当它前面是‘Jack’。<br> `/(?<=Jack|Tom)Spart/` 会匹配到 ’Spart‘仅仅当它前面是 ’Jack‘或者是 'Tom'。但是’Tom‘和’Jack‘都不是匹配结果的一部分 |
| `x(?！y)` | 匹配’x‘仅仅当’x‘后面不跟着’y‘, 这个叫做正向否定查找。<br> `/\d+(?!\.)/` 匹配一个数字仅仅当这个数字后面没有跟小数点的时候。 |
| `x|y` | 匹配’x‘或者’y‘。 |
| `{n}` | n是一个正整数，匹配了前面一个字符刚好发生了 n 次 |
| `{n,m}` | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是0，这个值会被忽略。 |
| `[xyz]` | 一个字符的集合。匹配方括号中的任意字符，包括转义序列。可以用破折号（-）来指定一个字符范围。对于点（.）和星号（\*）这样的特殊符号在一个字符集中没有特殊意义。 |
| `[^xyz]` | 一个反向字符集。匹配任何没有包含在方括号中的字符。同样可以使用破折号来指定一个字符范围。 |
| `[\b]` | 匹配一个退格(U+0008) |
| `\b` | 匹配一个词的边界。一个词的边界就是一个词不被另外一个字字符跟随的位置或者没有其他“字”字符在其前面的位置。 |
| `\B` | 匹配一个非单词边界。匹配一个前后字符都是相同类型的位置。都是’字‘字符或者都不是’字‘字符。一个字符串的开始和结尾都被认为不是‘字’字符，或者是字符串。 |
| `\cX` | 当 X 是处于A 到 Z 之间的字符的时候，匹配字符串中的一个控制符 |
| `\d` | 匹配一个数字 |
| `\D` | 匹配一个非数字字符 |
| `\f` | 匹配一个换页符（U+000C） |
| `\n` | 匹配一个换行符（U+000A） |
| `\r` | 匹配一个回车符（U+000D） |
| `\s` | 匹配一个空白符号，包括空格、制表符、换页符和换行符。<br>等价于 `[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]` |
| `\S` | 匹配一个非空白字符。<br>等价于 `[^ ` \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff `]` 。 |
| `\t` | 匹配一个水平制表符（U+0009） |
| `\v` | 匹配一个垂直制表符（U+000B） |
| `\w` | 匹配一个单字字符（字母、数字或者下划线）<br>等价于 `[A-Za-z0-9_]` |
| `\W` | 匹配一个单字字符<br>等价于 `[^A-Za-z0-9_]` |
| `\n` | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数） |
| `\0` | 匹配 NULL(U+0000)字符，不要在这后面跟着其他小数，因为 `\0<digits>` 是一个八进制转义序列 |
| `\xhh` | 与代码 hh 匹配字符（两个十六进制数字） |
| `\uhhhh` | 与代码 `hhhh` 匹配字符（四个十六进制数字） |

### 使用正则表达式

正则表达式被用于 RegExp 的 exec 和 test 方法，还有 String 的 match、replace、search和 split 方法。

| 方法 | 描述 |
| --------- '| ------------------------------------------------------------ |'
| `exec` | 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组(未匹配返回 null) |
| `test` | 一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或者 false |
| `match` | 一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配时返回 null |
| `search` | 一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回 -1 |
| `replace` | 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉后面的子字符串 |
| `split` | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的字符串存储到数组中的 String 方法 |

例子：

```javascript
// 脚本使用 exec 方法在一个字符串中查找一个匹配
let reg = /d(b+)d/g;
/**reg参数
 * 5 lastIndex 下一个匹配的索引值
 * "d(b+)d" source 模式文本。在正则表达式创建时更新，不执行
 */
let myArray = reg.exec('cdbbdbsbz');
myArray; // ["dbbd", "bb", index: 1, input: "cdbbdbsbz", groups: undefined]
/** myArray参数
 * ["dbbd,bb"] 匹配到的字符和所有被记住的子字符串
 * 1 1input 初始字符串
 * input:cdbbdbsbz  初始字符串
 */
// 不需要访问正则表达式的属性，通过另一个方法来创建
myArray = /d(b+)d/g.exec('cdbbdbsbz');

// 通过一个字符串构建正则表达式，还有另一种方式
reg = new RegExp('d(b+)d', 'g');
myArray = reg.exec('cdbbdbsbz');
```

#### 使用括号的子字符串匹配

一个正则表达式模式使用括号，将导致相应的子匹配被记住。使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。

```javascript
let reg = /(\w+)\s(\w+)/;
let str = 'John Smith';
let newStr = str.replace(reg, '$2,$1');
newStr; // "Smith,John"
```

#### 通过标志进行高级搜索

正则表达式有四个可选参数进行全局和不区分大小写搜索，这些参数可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。

| 标志 | 描述 |
| ---- '| ------------------------------------------------------------ |'
| `g` | 全局搜索 |
| `i` | 不区分大小写搜索 |
| `m` | 多行搜索(使用该标志， `^` 和 `$` 匹配的开始或者结束输入字符串的) |
| `y` | 执行“粘性”搜索，匹配从目标字符串的当前位置开始，可以使用 `y` 标志 |

格式：

```javascript
let reg = /pattern/flags;
let reg = /\w+\s/g;
// 或者
reg = new RegExp("pattern", "flags")
reg = new RegExp("\\w+\\s", "g")
```
