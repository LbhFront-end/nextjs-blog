---
title: '试题'
date:  '2018-05-12 08:12:40'
slug: 'Test'
tags: 'test'
categories: 
  - '试题'
---

试题
=============

### let\var\const  

1.const定义的变量不可以修改，而且必须初始化  
2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。  
3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。  

### 魔法币

小易准备去魔法王国采购魔法神器, 购买魔法神器需要使用魔法币, 但是小易现在一枚魔法币都没有, 但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。
魔法机器1: 如果投入x个魔法币, 魔法机器会将其变为2x+1个魔法币
魔法机器2: 如果投入x个魔法币, 魔法机器会将其变为2x+2个魔法币
小易采购魔法神器总共需要n个魔法币, 所以小易只能通过两台魔法机器产生恰好n个魔法币, 小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。

```javascript
var n = parseInt(readline()); //node.js输入
var n = 999;
var a = [];
var flag = true;
while (flag) {
    if (n > 2) {
        if (n % 2 == 0) {
            a.push(2);
            n = (n - 2) / 2;
        } else {
            a.push(1);
            n = (n - 1) / 2
        }
    } else {
        flag = false;
        a.push(n);
    }
}
console.log(a.reverse().join(''));
```

### 函数的参数名与全局变量相同，在函数内调用改变量名是对函数参数的调用，而不是对全局变量的调用

```javascript
var bb = 1;

function aa(bb) {
    bb = 2;
    alert(bb);
};
aa(bb); //2
alert(bb); //1
```

### Array

Array.prototype.shift(); 删除数组的第一个元素，并返回这个元素  
Array.prototype.unshift(); 在数组的开头增加一个或者多个元素，并且返回数组的新长度  
Array.prototype.pop(); 删除数组的最后一个元素，并返回数组的新长度  
Array.prototype.push(); 在数组的末尾增加一个或者多个元素，并且返回数组的新长度  
Array.prototype.sort(); 对数组进行排序，并返回该数组  
Array.prototype.reverse(); 颠倒数组中元素的排序顺序  
Array.prototype.splice(); 

### 事件委派

```javascript
var elements = document.getElementsByTagName('li');
var length = elements.length;
for (let i = 0; i < length; i++) {
    elements[i].onclick = function() {
        alert(i);
    }
} <
ul >
    <
    li > click me < /li> <
    li > click me < /li> <
    li > click me < /li> <
    li > click me < /li> <
    /ul>

var elements = document.getElementsByTagName('li');
var length = elements.length;

function handle(i) {
    return function() {
        alert(i);
    }
}
for (let i = 0; i < length; i++) {
    elements[i].onclick = handle(i);
}
```

### 写一个求和的函数sum，达到下面的效果

sum(1, 2, 3, 4, 5); 
// Should equal 0  
sum(5, null, -5); 
// Should equal 10  
sum('1.0', false, 1, true, 1, 'A', 1, 'B', 1, 'C', 1, 'D', 1, 
  'E', 1, 'F', 1, 'G', 1); 
// Should equal 0.3, not 0.30000000000000004  
sum(0.1, 0.2); 

```javascript
function sum() {
    var result = 0;
    for (var i = 0; l = arguments; i < l; i++) {
        result += (!isNaN(arguments[i]) && window.parseFloat(arguments[i])) || 0
    }
    return result.toFixed(3) * 1000 / 1000;
}
```

### 回文串问题

给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？
输出需要删除的字符个数。  

```javascript
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on('line', function(line) {
            var data = line.trim();
            var reverdata = data.split('').reverse().join('');
            var len = data.length;
            console.log(len - 'dynamic(data,reverdata));'
            });

        function dynamic(s1, s2) {
            var len1 = s1.length;
            var len2 = s2.length;
            var arr = new Array(len1 + 1);
            for (var i = 0; i <= len1; i++) {
                arr[i] = new Array(len2 + 1);
                console.log(arr);
            }
            for (var i = 0; i <= len1; i++) {
                arr[i][0] = 0;
            }
            for (var j = 1; j <= len2; j++) {
                arr[0][j] = 0;
            }
            for (var i = 1; i <= len1; i++) {
                for (var j = 1; j <= len2; j++) {
                    if (s1[i - 1] == s2[j - 1]) {
                        arr[i][j] = arr[i - 1][j - 1] + 1;
                    } else {
                        arr[i][j] = Math.max(arr[i][j - 1], arr[i - 1][j]);
                    }
                }
            }
            console.log(arr);
            return arr[len1][len2];
        }
        var a = dynamic('abgad', 'dagba'); console.log(a);
```

### 小Q最近遇到了一个难题：把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，且不能申请额外的空间。

你能帮帮小Q吗？  

```javascript
const readline = require('readline');
const rl = readline.creatrInterface({
    input: process.stdin,
    output: process.stdout
});
rl.on('line', function(line) {
    var token = line.split('');
    var len = token.length;
    var p = 0;
    for (var i = 0; i < l - p) {
        var num = token[i].charCodeAt(0);
        if (num <= 90) {
            token.push(tokens[i]);
            token.splice(i, 1);
            p++
        } else {
            i++
        }
    }
    console.log(tokens.join(''));
});
```

### 去重  

方法1  
思路：  
1. 构建一个新的数组存放结果  
2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比  
3. 若结果数组中没有该元素，则存到结果数组中	  

```javascript
Array.prototype.distinct = function() {
    var res = [this[0]]
    for (var i = 1; i < this.length; i++) {
        var repeat = false;
        for (var j = 0; j < res.length; j++) {
            if (this[i] == res[j]) {
                repeat = true;
                break;
            }
        }
        if (!repeat) {
            res.push(this[i])
        }
    }
    return res;
}
var arr = [7, 1, 2, 3, 1, 2, 2, 2, 3, 5, 6, 'a', 'a', 'b', 'd', 'e'];
console.log(arr.distinct());
```

方法2  
思路：  
1. 先将原数组进行排序  
2. 检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因 为已经排序，所以重复元素会在相邻位置  
3. 如果不相同，则将该元素存入结果数组中  

```javascript
Array.prototype.distinct = function() {
    this.sort();
    var res = [this[0]];
    for (var i = 1; i < this.length; i++) {
        if (this[i] !== res[res.length - 1]) {
            res.push(this[i]);
        }
    }
    return res;
}
var arr = [7, 1, 2, 3, 1, 2, 2, 2, 3, 5, 6, 'a', 'a', 'b', 'd', 'e'];
console.log(arr.ditinct());
```

方法3
1. 创建一个新的数组存放结果
2. 创建一个空对象
3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。

```javascript
Array.prototype.distinct = function() {
    var res = [];
    var json = {};
    for (var i = 0; i < this.length; i++) {
        if (!json[this[i]]) {
            res.push(this[i]);
            json[this[i]] = 1;
        }
    }
    return res;
}
var arr = [7, 1, 2, 3, 1, 2, 2, 2, 3, 5, 6, 'a', 'a', 'b', 'd', 'e'];
console.log(arr.distinct());
```

### 排序大小

```javascript
function mySort() {
    var tags = new Array();
    tags = Array.prototype.slice.call(arguments);
    console.log(arguments);
    console.log(arguments.length);
    console.log(tags);
    tags.sort(function(pre, next) {
        return pre - 'next;'
    })
    return tags;
}
var result = mySort(50, 11, 16, 32, 24, 99, 57, 100);
console.info(result);
```

### 前端开发的优化问题

（1） 减少http请求次数：css spirit, data uri

（2） JS，CSS源码压缩

（3） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（4） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能

（5） 用setTimeout来避免页面失去响应

（6） 用hash-table来优化查找

（7） 当需要设置的样式很多时设置className而不是直接操作style

（8） 少用全局变量

（9） 缓存DOM节点查找的结果

（10） 避免使用CSS Expression

（11） 图片预载

（12） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢
